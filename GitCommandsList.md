# Общая информация - что такое система контроля версий Git:

Git — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит). Важно: добавление файлов к «сохранению» двухступенчатое: сначала добавляем файл в индекс (git add), потом «сохраняем» (git commit).

Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).

1. Отслеживаемый.(tracked)

Об этих файлах Git знает и отслеживает изменения в них. Отслеживаемые файлы в свою очередь могут находится в следующих состояниях:

* Неизмененный.(unmodified) То есть с момента последнего коммита в файле не было никаких изменений

* Измененный.(modified) То есть с последнего коммита в файле были произведены какие-то изменения.

* Подготовленный к коммиту.(staged) Это значит, что вы внесли изменения в этот файл и затем проиндексировали их, и эти изменения будут добавлены в следующий коммит.

2. Неотслеживаемый.(untracked)

О неотслеживаемых файлах Git не знает, поэтому изменения в них не будут добавлены в коммит. Это любые файлы в вашем рабочем каталоге, которые не входили в последний коммит и не подготовлены к текущему коммиту.

[Наглядная визуализация состояний файлов и переходов между ними.](Project_Images/1_Git_file_statuses.png)

**Ключ к пониманию концепции git — знание о трех разделах:**

[Git отслеживает файлы в трёх основных разделах:](Project_Images/Git_Project_directories.png)

* Рабочая директория - Working directory. Это файловая структура, с которой непосредственно работает пользователь в конкретный момент времени. Технически же - это копия определенной версии вашего проекта, которую вы извлекли из базы Git и в которую пытаетесь внести свои изменения.

* Индекс или Область подготовленных файлов - Index / Staging area. Это область, где хранятся имена файлов и изменения в них, которые должны войти в следующий коммит. Технически индекс - это просто файл.

* Директория Git - Git Directory. Папка, в которой Git хранит все версии вашего проекта и также свои служебные файлы. Данная папка носит название .git и располагается в корневой директории вашего проекта. [Это та самая скрытая папка .git.](Project_Images/GitFolder.png)

Все основные команды по работе с файлами сводятся к пониманию того, как Git управляет этими тремя разделами. Существует распространённое заблуждение, что область подготовленных файлов только хранит изменения. Лучше думать об этих трёх разделах как об отдельных файловых системах, каждая из которых содержит свои копии файлов. 

[Файловая система Git - тык и смотри пояснения ниже](Project_Images/git_workflow.png) 

```Развернутый комментарий к схеме разделов Git:```

1. Working derictory - изначальные файлы, с которыми вы работаете на вашем компьютере
2. Применяем команду *git add* , то есть просим Git проиндексировать файлы и начать наблюдать за ними.
3. Staging area - наши файлы оказались списке отслеживаемых git-ом файлов и директорий. Иными словами этот раздел представляет собой обычный файл, обычно хранящийся в каталоге Git, который содержит информацию о том, что должно войти в следующий коммит. Иногда его называют индексом (index), но в последнее время становится стандартом называть его областью подготовленных файлов.
4. Мы фиксируем (*git commit*) финальное или промежуточное состояние наших файлов (делаем точку сохранения с которой патом сможем продолжить, по аналогии с играми)
5. Local Repository - зафиксированные файлы оказываются в локальном репозитории Локальный репозиторий - это репозиторий, который хранится на нашем компьютере, в рабочей папке проекта. [Это та самая скрытая папка .git.](Project_Images/GitFolder.png)

Пройдя выше упомянутый путь мы сможем работать с удалённым репозиторием Remote repository (например GitHub) отправлять туда информацию (push) и брать оттуда информацию в наш локальный репозиторий (pull).

*Получаем простейший цикл нашего рабочего процесса:*

* Редактирование, добавление, удаление файлов (собственно, работа). 

* Индексация/добавление файлов в индекс (указание для git какие изменения нужно будет закоммитить).

* Коммит (фиксация изменений).

* Возврат к шагу 1 или завершение работы

**Указатели:**

*Немного про указатели*
Указатель – это ссылка на определенный коммит или ветку. А ссылка – это некоторая метка, которую использует Git или сам пользователь, чтобы указать на коммит или ветку. И как мы уже сказали, физически ветки – самые настоящие указатели ведь они указывают на коммит. При добавлении коммита, указатель ветки перемещается с родительского коммита на новый. 

**Давайте приведем примеры еще некоторых часто используемых указателей:**

* HEAD – так называемый курсор Git. Главное назначение HEAD - определять, в каком состоянии находится рабочая копия (напомним, что рабочая копия – это все файлы репозитория, за исключением директории .git/). На какой коммит указывает HEAD – из того коммита и загружаются файлы в рабочую директорию.
* ORIG_HEAD – указатель, который появляется, когда мы вручную передвигаем HEAD на какой-нибудь НЕ последний коммит. ORIG_HEAD указывает на тот же коммит, на который указывал HEAD до передвижения назад. Нужен он, чтобы мы имели возможность вернуться на хронологически последний коммит без существенных затрат (в истории мы не будем видеть все коммиты старше нашего, а поэтому не сможем узнать хэш последнего).
### История изменений указателей (веток, HEAD)

``` bash
git reflog -20  # показать последние 20 изменений положения указателя HEAD
git reflog --format='%C(auto)%h %<|(20)%gd %C(blue)%cr%C(reset) %gs (%s)' -20 # то же, но с указанием давности действий
```
* Пользовательские указатели.(Теги, комментарии) Пользователи сами могут создавать указатели. Например, вы можете создать указатель version-1.2.1, который будет указывать на коммит, в котором хранится версия 1.2.1 вашего проекта. Это довольно удобно, поскольку вы можете переключаться на коммит с той или иной версией, не запоминая его хэш.
### Теги:

``` bash
git tag v1.0.0               # создать тег с указанным именем на коммите, на который указывает HEAD
git tag -a -m 'В продакшен!' v1.0.1 master # создать тег с описанием на том коммите, на который смотрит ветка master
git tag -d v1.0.0            # удалить тег с указанным именем(ами)
git tag -n                   # показать все теги, и по 1 строке сообщения коммитов, на которые они указывают
git tag -n -l 'v1.*'         # показать все теги, которые начинаются с 'v1.*'
```

Преимущество веток в их независимости. Вы можете вносить изменения в файлы в одной ветке, например, пробовать новую функцию, и они никак не скажутся на файлах в другой ветке. Изначально в репозитории одна ветка, но позже мы рассмотрим, как создавать другие.

На самом деле, вначале, когда мы делаем свой первый коммит, Git автоматически создает основную ветку и её имя по умолчанию "main" или "master". Каждый раз, когда мы создаем новый коммит, Git автоматически перемещает указатель main или master на последний коммит.

[Представление веток внутри Git](Project_Images/BranchesStructure.webp)

На рисунке овалы с хэшами – наши коммиты, main – ветка по умолчанию и в то же время указатель на коммит 62aa, а HEAD – указатель на ветку, с которой мы сейчас работаем, то есть на ветку main.
# Первостепенные команды после установки Git на компьтер:

Первое, что вам следует сделать после установки Git — указать ваше имя и адрес электронной почты. Это важно, потому что каждый коммит в Git содержит эту информацию, и она включена в коммиты, передаваемые вами, и не может быть далее изменена после начала работы над проектом и осуществления комиттов:

*   *git config --global user.name "Name"*

*   *git config --global user.email yourname@example.com*

После указания своих данных, можно их просмотреть:

* *git config --global --list*

Чтобы установить имя main для вашей ветки по умолчанию, выполните следующую команду:

*  *git config --global init.defaultBranch main*

Имя главной ветки может быть любым, но для оптимизации работы есть правила хорошего тона которые следуетс соблюдать в зависимости от требований и желаний участников рабочего процесса... Так например, с 2020 года GitHub выступает за то, чтобы главная ветка называлась main (по политическим причинам) и настоятельно рекомендует переименовать ветку

# Инициализация репозитория:

Создать пустой репозиторий Git или вновь инициализировать существующий можно параметром init. При инициализации он создаст [скрытую папку.](Project_Images/GitFolder.png) В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.

* *git init*  --> создать новый проект в текущей директории

* *git init folder-name*  --> создать новый проект в указанной директории

# Определение состояния файлов:

Команда git status отображает все файлы, которые различаются между тремя разделами. 
У файлов есть 4 состояния:
* Неотслеживаемый (untracked) — находится в рабочей директории, но нет ни одной версии в HEAD или в области подготовленных файлов (Git не знает о файле).
* Изменён (modified) — в рабочей директории есть более новая версия по сравнению с хранящейся в HEAD или в области подготовленных файлов (изменения не находятся в следующем коммите).
* Подготовлен (staged) — в рабочей директории и области подготовленных файлов есть более новая версия по сравнению с хранящейся в HEAD (готов к коммиту).
* Без изменений — одна версия файла во всех разделах, т. е. в последнем коммите содержится актуальная версия.

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда :

* *git status*

Файл может быть одновременно в состоянии «изменён» и «подготовлен», если версия в рабочей директории новее, чем в области подготовленных файлов, которая в свою очередь новее версии в HEAD. Мы можем использовать опцию -s для команды git status, чтобы получить более компактный вывод (по строке на файл). Если файл не отслеживается, то будет выведено что он не отслеживается; если он был изменён, то его имя будет красным, а если подготовлен — зелёным.

# Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл:

* *git add text.txt* --> добавить в индекс указанный файл (был изменён, был удалён или это новый файл)

* *git add .*  --> добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий
[Команда git add. Добавление новых изменений файла в индекс.](Project_Images/change_and_add_fil.png)

* *git add -A* или *git add --all*--> добавляем вообще все измененные файлы с корня проекта в индекс:

Полезные параметры команды git add:
* -f, --force — также добавить в индекс  игнорируемые файлы
* -u, --update — обновить уже отслеживаемые файлы
* -p, --patch позволяет выбрать какие изменения из файла добавятся в коммит а какие изменения в этом же файле нет. Используя эту команду, вы не добавляете все свои изменения сразу, а добавляете их небольшими «патчами». В будущем вы сможете решить, хотите ли вы добавить какое-либо изменение в свой коммит или нет. Git будет спрашивать вас о каждом патче, а вы примите решение: введете y для «да» или n для «нет»
* -i  --interactive запустить интерактивную оболочку для добавления в индекс только выбранных файлов
--interactive (или -i) это большой брат опции --patch. --patch ограничивается предоставлением информации по hunks из файла или фалов. --interactive предоставляет вам намного больше возможностей. Настолько больше, что у данного режима есть свое собственное меню:

*** Commands: ***
~~~~ re
1: [s]tatus 
2: [u]pdate 
3: [r]evert 
4: [a]dd untracked
5: [p]atch  
6: [d]iff   
7: [q]uit   
8: [h]elp
~~~~
1. [s]tatus - Аналогично git status отобразит состояние индекса
2. [u]pdate - Позволяет добавить данные в индекс. Можно провести аналогию с git add -u .... Фактически работает только с теми файлами рабочей директории, которые находятся под версионным контролем
3. [r]evert - Отменяет изменения файлом до состояния HEAD. Действие аналогично команде git checkout path, или git reset --hard HEAD path
4. [a]dd untracked - Добавление не отслеживаемых файлов в индекс
5. [p]atch - Добавление части изменений. Аналогично команде git add -p path
6. [d]iff - Отобразить дифф изменений между индексом и HEAD. Аналогично команде git diff --cached path
7. [q]uit - Выйти из интерактивного режима индексирования
8. [h]elp - Отобразить справочную информацию
Отличительная особенность этого режима в том, что вы можете указать какой именно файл(ы) обрабатывать.

# Перемещение/переименование файлов

Для git не существует переименования. Переименование воспринимается как удаление старого файла и создание нового. Факт переименования может быть определен только после индексации изменения.

``` bash
git mv text.txt test_new.txt --> переименовать файл «text.txt» в «test_new.txt» и проиндексировать это изменение
git mv readme_new.md folder/ --> переместить файл readme_new.md в директорию folder/ (должна существовать) и проиндексировать это изменение
По сути эти команды эквивалентны применению 2-х комманд подряд: 
*mv -r original_file/folder_name new_file/folder_name + *add .*
```
# Удаление файлов:

* *git rm <имя файла>* - отменяет отслеживание файла и удаляет его из рабочей директории иными словами удаляет отслеживаемый неизменённый файл и проиндексирует это изменение
* *git rm -f <имя файла>* - удалить отслеживаемый изменённый файл и проиндексировать это изменение
* *git rm -r log/* - удалить всё содержимое отслеживаемой директории log/ и проиндексировать это изменение
* *git rm ind*\*  - удалить все отслеживаемые файлы с именем, начинающимся на «ind» в текущей директории и проиндексировать это изменение
* *git rm --cached <имя файла>* - удалить из отслеживаемых индексированный файл (ФАЙЛ ОСТАНЕТСЯ НА МЕСТЕ) (часто используется для нечаянно добавленных в отслеживаемые файлов)

**Пример:**

Удалим файл sample.txt из рабочей копии и индекса: -->  *git rm sample.txt*

Удалим файл sample.txt из индекса и перемеcтим его в категорию Untracked --> *git rm --cached sample.txt*

[Удаляйте файлы через Git правильно](Project_Images/GitHowToDeleteCorrectly.png)

# Восстановление файлов после удаления:

Если мы захотим восстановить файл после удаления или изменения в рабочей копии или индексе - для этого существует команда *git restore.*

*git restore <ключ> <имя файла>* 

**Ключи**
*-s, --source= < tree >* --> Этот ключ нужен, чтобы передать команде путь к коммиту (ветке, пользовательскому указателю), откуда мы будем восстанавливать файл. По умолчанию файл берется из области индекса.

*--worktree* (англ. рабочая копия)
*--staged* (англ. область индекса)

Эти два ключа позволяют указать, где именно восстанавливать файл. По умолчанию, если ни один из этих двух ключей не передан, файл восстанавливается только в рабочей копии.

Если же передан ключ *--staged*, файл восстанавливается только в области индекса. В этом случае источником восстановления по умолчанию является коммит, на который указывает HEAD (поскольку мы не можем восстановить файл в области индекса из самой же области индекса).

Если же вы хотите восстановить файл и в рабочей копии, и в области индекса, вам нужно передать оба ключа.

**Примеры:**

Если вы случайно удалили файл sample.txt обычным способом, то можно восстановить его из индекса --> *git restore sample.txt*

Вернем файл sample.txt к определенному коммиту с хэшем 09c2240. При этом мы изменим только файл в рабочей копии, файл в области индекса не поменяется.
--> *git restore --source 09c2240 sample.txt*

Вернем файл sample.txt в индексе к состоянию последнего коммита (отменим все внесенные изменения или удалим файл, если в предыдущем коммите его не было), при этом изменения коснутся только индекса файла, рабочая копия не поменяется.
--> *git restore --staged sample.txt*

Сделаем то же, что и в предыдущем примере, но теперь изменения затронут и файл в рабочей копии.
--> *git restore --staged --worktree sample.txt*

# Игнорирование файлов:

Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.). В таком случае, файлы и директории, которые не нужно включать в репозиторий, указываются в файле `.gitignore`. Обычно это устанавливаемые зависимости (`node_modules/`, `bower_components/`), готовая сборка `build/` или `dist/` и подобные, создаваемые при установке или запуске. Каждый файл или директория указываются с новой строки, [возможно использование шаблонов](http://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D1%8C-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B2-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B9#Игнорирование-файлов) соответствующих таким файлам.С помощью различных символов можно создавать собственные шаблоны. 
Чтобы отметить файлы, которые мы хотим игнорировать, можно использовать эти шаблоны поиска (считайте их упрощёнными регулярными выражениями):

* /___ — позволяет избежать рекурсивности — соответствует файлам только в текущей директории;
* __/ — соответствует всем файлам в указанной директории;
* ___ — соответствует всем файлам с указанным окончанием;
* ! — игнорирование файлов, попадающих под указанный шаблон;
* [__] — соответствует любому символу из указанных в квадратных скобках;
* ? — соответствует любому символу;
* /**/ — соответствует вложенным директориям, например a/\*\*/d соответствует a/d, a/b/d, a/b/c/d и т. д.
Мы даже можем использовать шаблоны поиска при указании файла/папки в других командах. Например, git add src/*.css добавит все файлы .css в папке src.

[Подробное описание в документации пректа на стр 32](Project_Documentation/progit.pdf)

# Внесение изменений однострочным сообщением или через редактор - git commit:

Команда git commit откроет [текстовый редактор](VimTextRedactorSummary.md) для ввода сообщения коммита. 
Также эта команда принимает несколько аргументов:

* -m позволяет написать сообщение вместе с командой, не открывая редактор:
*git commit -m "Залил фотку Тефтельки"*
 
* -a переносит __Вcе__ отслеживаемые файлы в область подготовленных файлов и включает их в коммит (позволяет нам пропустить *git add* перед коммитом);
После команды *git commit -a* запускается текстовый редактор в котором делаем описание коммита.(Этот вариант подходит для развёрнутых комментариев)Можно добавить ключ -m и сделать *краткое* пояснение к коммиту без вызова редактора: *git commit -am "Залил фотку Тефтельки"*

**Важно понимать что хоть ключ -a и позволяет пропустить добавление в индекс, однако он работает только с файлами которые Git уже отслеживает и игнорирует все остальные untracked файлы!**

* Если подготовлено несколько файлов, но хотим закомитить только какой-то один - достаточно указать конкретный путь, например:
*git commit -m .gitignore* делает коммит только для одного modified файла .gitignore и не затрагивает остальные. При этом действует тоже ограничение что и для -a: файлы которые Git не отслеживает - будут проигнорированны.Иными словами это работает также толко для приндексированных файлов.

* --amend заменяет последний коммит новым изменённым коммитом, что бывает полезно, если вы неправильно набрали сообщение последнего коммита или забыли включить в него какие-то файлы.
*git commit --amend -m "Залил фотку Тефтельки - я молодец!"*

Коммиты хранят состояние файловой системы в определённый момент времени и указатели на предыдущие коммиты. Каждый коммит содержит уникальную контрольную сумму — идентификатор, который Git использует, чтобы ссылаться на коммит. Чтобы отслеживать историю, Git хранит указатель HEAD, который указывает на первый коммит (мы следуем по цепочке коммитов в обратном порядке, чтобы попасть к предыдущим коммитам).
[Историю коммитов визуально можно отобразить так](Project_Images/commit-history-970x386.webp)

* Коммитьте как можно чаще.
* Одно изменение — один коммит: не помещайте все не связанные между собой изменения в один коммит, разделите их, чтобы было проще откатиться.
* Формат сообщений: заголовок должен быть в повелительном наклонении, меньше 50 символов в длину и должен логически дополнять фразу this commit will ___(this commit will fix bugs — этот коммит исправит баги). Сообщение должно пояснять, почему был сделан коммит, а сам коммит показывает, что изменилось.
* Если у вас много незначительных изменений, хорошим тоном считается делать небольшие коммиты при разработке, а при добавлении в большой репозиторий объединять их в один коммит.

# Просмотр истории коммитов с изменениями

Просматривать изменения, внесённые в репозиторий, можно с помощью параметра log. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг -p, вы можете подробно изучить изменения, внесённые в конкретный файл.

* *git log*  - общий журнал всех изменений
* *git log -p имя файла.расширение* - список изменений для внесённых в конкретный файл.
* *git log --graph* - история в виде дерева (Выводит коммиты в виде дерева, в командной строке псевдографикой. Плюс выводит список измененных файлов.)
* *git log --oneline*- выводит журнал форме короткого списка c комметариями коммитов и хешем из первых 7 символов 
[Это очень полезная команда](Project_Images/GitLogOneLine.png)
## Примеры:
Выход из длинного лога вывода: `q`.

``` bash
git log master             # показать коммиты в указанной ветке master
git log -2                 # показать последние 2 коммита в активной ветке
git log -2 --stat          # показать последние 2 коммита и статистику внесенных ими изменений
git log -p -22             # показать последние 22 коммита и внесенную ими разницу на уровне строк
git log --graph -10        # показать последние 10 коммитов с ASCII-представлением ветвления
git log --since=2.weeks    # показать коммиты за последние 2 недели
git log --after '2018-06-30' # показать коммиты, сделанные после указанной даты
git log index.html         # показать историю изменений файла index.html (только коммиты)
git log -5 index.html      # показать историю изменений файла index.html, последние 5 коммитов (только коммиты)
git log -p index.html      # показать историю изменений файла index.html (коммиты и изменения)
git log -G'myFunction' -p  # показать все коммиты, в которых менялись строки с myFunction (в кавычках регулярное выражение)
git log -L '/<head>/','/<\/head>/':index.html # показать изменения от указанного до указанного регулярных выражений в указанном файле
git log --grep fix         # показать коммиты, в описании которых есть буквосочетание fix (регистрозависимо, только коммиты текущей ветки)
git log --grep fix -i      # показать коммиты, в описании которых есть буквосочетание fix (регистроНЕзависимо, только коммиты текущей ветки)
git log --grep 'fix(ing|me)' -P # показать коммиты, в описании которых есть совпадения для регулярного выражения (только коммиты текущей ветки)
git log --pretty=format:"%h - %an, %ar : %s" -4 # показать последние 4 коммита с форматированием выводимых данных
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short # мой формат вывода, висящий на алиасе оболочки
git log master..branch_99  # показать коммиты из ветки branch_99, которые не влиты в master
git log branch_99..master  # показать коммиты из ветки master, которые не влиты в branch_99
git log master...branch_99 --boundary -- graph # показать коммиты из указанных веток, начиная с их расхождения (коммит расхождения будет показан)
```

# Просмотр заданного коммита:

Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра show, указав идентификатор или хеш коммита. Значение хеша уникально для каждого коммита, созданного в вашем репозитории.

* *git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29*

Также можно использовать сокращённый хеш:

* *git show 1af1*

Также можно увидеть более подробную информацию о коммите и узнать кто автор изменений, а кто сделал сам коммит(без хеша выводит информацию по последнему коммиту):

* *git show --pretty=fuller хеш*

## Примеры:

``` bash
git show 60d6582           # показать изменения из коммита с указанным хешем 60d6582
git show HEAD~             # показать данные о предыдущем коммите в активной ветке
git show @~                # аналогично предыдущему
git show HEAD~3            # показать данные о коммите, который был 3 коммита назад
git show my_branch~2       # показать данные о коммите, который был 2 коммита назад в указанной ветке
git show @~:index.html     # показать контент указанного файла на момент предыдущего (от HEAD) коммита
git show :/"подвал"        # показать самый новый коммит, в описании которого есть указанное слово (из любой ветки)
```
# Для переключения на нужный коммит 

Используется действие checkout. После переключения, все файлы в проекте станут такими, какими они были в данном коммите.

* *git checkout хеш*

*Где хеш - обозначение, имя коммита, причем можно указывать не весь хеш, а несколько начальных символов  (4 первых символа как правило достаточно)*

# Возвращаемся к основной ветке

* *git checkout master*  __or__  *git checkout main*

# Копирование коммита (перенос коммитов)

``` bash
git cherry-pick 5589877          # скопировать на активную ветку изменения из указанного коммита, закоммитить эти изменения
git cherry-pick master~2..master # скопировать на активную ветку изменения из master (2 последних коммита)
git cherry-pick -n 5589877       # скопировать на активную ветку изменения из указанного коммита, но НЕ КОММИТИТЬ (подразумевается, что мы сами потом закоммитим)
git cherry-pick master..feature  # скопировать на активную ветку изменения из всех коммитов ветки feature с момента её расхождения с master (похоже на слияние веток, но это копирование изменений, а не слияние), закоммитить эти изменения; это может вызвать конфликт
git cherry-pick --abort    # прервать конфликтный перенос коммитов
git cherry-pick --continue # продолжить конфликтный перенос коммитов (сработает только после решения конфликта)
```

# Просмотр изменений и сравнение с последним коммитом

Для вывода изменений в файлах по сравнению с последним коммитом, используется *git diff* без параметров. Команда выводит изменения в файлах, которые еще не были добавлены в индекс. Сравнение происходит с последним коммитом.

``` bash
git diff                # сравнить рабочую директорию и индекс (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff --color-words  # сравнить рабочую директорию и индекс, показать отличия в словах (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff index.html     # сравнить файл из рабочей директории и индекс
git diff HEAD           # сравнить рабочую директорию и коммит, на который указывает HEAD (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff --staged       # сравнить индекс и коммит с HEAD
git diff master feature # посмотреть что сделано в ветке feature по сравнению с веткой master
git diff --name-only master feature # посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов
git diff master...feature # посмотреть что сделано в ветке feature с момента (коммита) расхождения с master
```
# Ветвления:

Ветка – независимая последовательность коммитов. Ветки нужны, чтобы тестировать новые функции и распараллеливать работу над проектом.
Первоначально мы работаем в основной ветке. У нас она называется main.
Обычно в основной ветке находится та же версия кода, что и в продакшене. То есть если в основную ветку попадут какие-то непроверенные изменения, код может сломаться и повлечь за собой поломку приложения у конечного пользователя. Поэтому во всех командах, работающих над серьезными проектами, принято, что в основной ветке находятся только протестированные изменения, которые в идеале не придется экстренно исправлять.

То есть общий ход нашей работы выглядит следующим образом:

1. Решили добавить новую функцию – создали отдельную ветку. Дальше работаем в новой ветке.
2. Написали функцию, протестировали ее работу, внесли все необходимые исправления, еще раз протестировали и убедились, что функция работает исправно и не привнесла ошибок в остальной код.
3. Теперь нужно как-то перенести изменения с тестовой ветки на основную – в продакшн. Тут нам на помощь и приходит слияние: мы просто сливаем (т.е. переносим) изменения с нашей тестовой ветки в основную.

* Создание ветки:

*git branch Имя_ветки*

* Переключение между ветками:

*git checkout Имя_ветки*

* Создание ветки и сразу переключение на неё:

*git checkout –b Имя_ветки*

**Lifehack:** механизм создания новых веток не так прост, как может показаться некоторым на  первый взгляд. Так данный функционал можно использовать для отката ветки к предыдущему состоянию с сохранением данных --> Например: мы реализовали механизм проверки пароля для личного кабинета в нашем проекте и сделали коммит в основной ветке где как правило хранится окончательный код, но после ряда обсуждений пришли к выводу что надо добавить капчу при проверке пароля.
Как нам откатить нашу ветку main __or__ master и при этом вернуться к требуемому коду чтобы его доработать?
Всё просто: мы находимся на гланой ветке и наш HEAD указывает на эту ветку, которая  в свою очередь указывает на текущий коммит - пусть это будет коммит с хешем 4594. Давайте создадим новую ветку git branch fix. Мы всё еще на гланой ветке и обе ветки master & fix указывают на один и тот же коммит 4594. Переходим на ветку fix --> *git checkout fix*. А теперь давайте [передвинем главную ветку](Project_Images/FiXBranch.png) к состоянию предыдущего коммита когда механизм реализации пароля еще не был добавлен в репозиторий. Воспользуемся командой которую мы уже знаем: *git branch -f master 54a4* где хеш 54a4 указывает на интересующий нас коммит а ключ -f (force) использован чтобы заставить Git создать новую ветку master, хотя такая ветка уже существует. Теперь мы можем вести разработку в новой ветке fix, а основная ветка вернулась к прердыдущему состоянию благодаря нашему переносу веток "вручную"
[Вот так это выглядит](Project_Images/FixBranchWorked.png)
Если  допустим мы передумали - можем вернуть master обратно к состоянию ветки fix ссылающейся на коммит с хешем 4594 --> *git branch -f master fix* [И вот что получится --> тык](Project_Images/FixBranchAndMasterOnTheSameCommit.png). В Git ветка не может указывать на другую ветку - только на коммит. Поэтому fix в комманде выше это идентификатор коммита с хешем 4594. Для перемещения главной ветки также можно было использовать команду: *git checkout -B master 54a4*. 
[По сути это тоже самое что](Project_Images\FixBranchCheckout.png) --> *git checkout fix* + *git branch -f master 54a4*.
Также можно использовать git checkout для восстановления изменений конкретного файла, а не ветки
*git checkout хеш yourfile.html  --> восстановить в рабочей директории указанный файл на момент указанного коммита и добавить это изменение в индекс (git reset yourfile.html для удаления из индекса, но сохранения изменений в файле)

* Переименование ветки:

*git branch –m Старое_название_ветки Новое_название_ветки*

* Удаление ветки:

Удалить ветку можно параметром branch с добавлением флага -d и указанием имени ветки. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.

*git branch –d Имя_ветки*

Для принудительного удаления ветки используется флаг -D с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.

*git branch –D Имя_ветки*

**Примечание:**

Допустим мы осуществили какие-то изменения в нашем проекте, но пока что они сырые и мы их не можем зафиксировать. Вдруг нам нужно срочно переключить ветку - допустим на main... Мы используем *git checkout main* , но Git отказывается переходить и бьёт тревогу потому что данные для которых мы не сделали коммит могут безвозвратно кануть в бездну небытия:). Это работает следующим образом: если просто переключить ветки посреди работы, то все изменённые файлы перенесутся в новую ветку, а если изменнения конфликтуют, то и не переключится ничего. Какие варианты у нас тогда есть? Допустим мы подумали и решили что не нужны нам все эти данные, но ветку мы всё-таки хотим поменять - тогда просто добавим флаг -f который обозначает force.
Вводим комманду *git checkout -f main* и переходим на главную ветку. 
__Lifehack:__ Используя этот принцип можно всегда откатить все изменения которые мы проделали в проекте, но не закоммтили -  "git checkout -f" по умолчанию ссылается на HEAD (текущую ветку). Находясь в HEAD вводим эту комманду *git checkout -f* но смены ветки как таковой фактически не происходит ведь мы остаёмся там же, однако Git перезаписывает все файлы заменяя их версиями из репозитория на момент HEAD.
Теперь давайте расссмотрим вариант когда данные нам всё-таки нужны, но коммит еще совершать нецелесообразно: для этого есть комманда *git stash* Этак команда собирает все изменнения без коммитов, удаляет их из файлов и архивирует в специальном виде в Git.(a stash c английского - заначка, тайник) Чтобы вернуть изменения из нашего тайника надо вернуться на соотвествующую ветку и использовать *git stash pop*  При желании и необходимости можно вызвать эту комманду на другой ветке и перенести все наши изменнения туда, однако стоит быть очень аккуратным чтобы не создать конфликты при таком переносе поэтому чаще всего возвращаются на исходную ветку.

## Примеры основных команд для работы с ветками:

``` bash
git branch                 # показать список веток
git branch -v              # показать список веток и последний коммит в каждой
git branch new_branch      # создать новую ветку с указанным именем на текущем коммите
git branch new_branch 5589877 # создать новую ветку с указанным именем на указанном коммите
git branch -f master 5589877  # переместить ветку master на указанный коммит
git branch -f master master~2 # переместить ветку master на 2 коммита назад
git checkout new_branch    # перейти в указанную ветку
git checkout -b new_branch # создать новую ветку с указанным именем и перейти в неё
git checkout -B master 5589877 # переместить ветку с указанным именем на указанный коммит и перейти в неё
git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix
git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)
git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов
git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния
git branch -d hotfix       # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)
git branch --merged        # показать ветки, уже слитые с активной
git branch --no-merged     # показать ветки, не слитые с активной
git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)
git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name
git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name
git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории
git branch --unset-upstream # завершить процесс переименования
```
 # Алгоритм cлияния веток:

1. Переключиться на ветку, в которой будут приняты изменения: *git checkout имя_ветки*

2. Указать ветку, в которой будут приняты изменения: *git merge ветка_с_нужными_изменениями*

# «Перенос» ветки:

Можно «переместить» ответвление какой-либо ветки от основной на произвольный коммит. Это нужно для того, чтобы в «переносимой» ветке появились какие-либо изменения, внесённые в основной ветке (уже после ответвления переносимой).

Нельзя «переносить» ветку, если она уже отправлена на удалённый репозиторий.

``` bash
git rebase master # перенести все коммиты (создать их копии) активной ветки так, будто активная ветка ответвилась от master на нынешней вершине master (часто вызывает конфликты)
git rebase --onto master feature # перенести коммиты активной ветки на master, начиная с того места, в котором активная ветка отделилась от ветки feature
git rebase --abort # прервать конфликтный rebase, вернуть рабочую директорию и индекс к состоянию до начала rebase
git rebase --continue # продолжить конфликтный rebase (сработает только после разрешения конфликта и индексации такого разрешения)
```
# Как отменить rebase

``` bash
git reflog feature -2        # смотрим лог перемещений ветки, которой делали rebase (в этом примере — feature), видим последний коммит ПЕРЕД rebase, на него и нужно перенести указатель ветки
git reset --hard feature@{1} # переместить указатель ветки feature на один коммит назад, обновить рабочую директорию и индекс
```

# Конфликты слияния веток:

Для того, чтобы выяснить, в каких файлах есть конфликты, нужно набрать Git команду: *git status*
Все, что находится в HEAD - это наши изменения, и все, что находится после знаков равно (======)- это внешние изменения.    

[Вот как это выглядит](Project_Images/merge.png)

Вам нужно выбрать, какие изменения оставить: current change(версия из изначальной ветки) или incoming change(версия из ветки которую хотим объединить с изначальной)

Для этого выбираем в выпадающем окне один из возможных вариантов:
1. Accept Current Change (Принимаем версию из изначальной ветки)
2. Accept Incoming Change (Принимаем новую версию из второй ветки)
3. Accept Both Changes (Принимаем сразу оба варианта)
4. Compare Changes (Сравнить и показать разницу)

После того как решите конфликты, нужно использовать Git команду: *git commit*

## Конфликт слияния и несколько полезных комманд  через консоль для данной ситуации:

Предполагается ситуация: есть ветка `master` и есть ветка `feature`. В обеих ветках есть коммиты, сделанные после расхождения веток. В ветку `master` пытаемся влить ветку `feature` (`git merge feature`), получаем конфликт, т.к. в обеих ветках есть изменения одной и той же строки в файле `index.html`.

При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.

``` bash
git merge feature                # влить в активную ветку изменения из ветки feature
git merge-base master feature    # показать хеш последнего общего коммита для двух указанных веток
git checkout --ours index.html   # оставить в конфликтном файле (index.html) состояние ветки, В КОТОРУЮ мы вливаем (в примере — из ветки master)
git checkout --theirs index.html # оставить в конфликтном файле (index.html) состояние ветки, ИЗ КОТОРОЙ мы вливаем (в примере — из ветки feature)
git checkout --merge index.html  # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток (для ручного редактирования)
git checkout --conflict=diff3  --merge index.html # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток плюс то, что было в месте конфликта в коммите, на котором разошлись сливаемые ветки
```

``` bash
git reset --hard  # прекратить это прерванное слияние, вернуть рабочую директорию и индекс как было в момент коммита, на который указывает HEAD, а я пойду немного поплачу
git reset --merge # прекратить это прерванное слияние, но оставить изменения, не закоммиченные до слияния (для случая, когда слияние делается не на чистом статусе)
git reset --abort # то же, что и строкой выше
```

# Прекращение слияния веток при конфликте

Прервать слияние в случае конфликта можно параметром merge с флагом --abort. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.

* *git merge --abort*

# Отмена коммитов и перемещение по истории. Команда git revert.

Пожалуй одна из самых важных частей в изучении Git – научиться откатываться к предыдущим коммитам. Смысл отката мы обсуждали в предыдущих уроках: ваш проект может перестать работать по непонятным вам причинам после внесения некоторых изменений в код, в таком случае важно быстро вернуть все к рабочему состоянию и только потом заниматься поиском ошибки. В этом-то случае нам и поможет откат коммитов и команда git revert.Все коммиты, которые уже были отправлены в удалённый репозиторий, должны отменяться новыми коммитами (git revert), дабы избежать проблем с историей разработки у других участников проекта.

    git revert HEAD  --> создать новый коммит, отменяющий изменения последнего коммита 

*git revert HEAD --no-edit*  --> создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения

*git revert b9533bb --no-edit*  --> то же что и выше, но отменяются изменения, внесённые коммитом с указанным хешем (b9533bb)

*git revert HEAD~2* -->  отменяются изменения, внесенные 2 коммита назад

*git revert HEAD~5..HEAD~2* --> отменяются изменения, начиная с пятого с конца и заканчивая вторым с конца.

**Разница между revert и reset**

Команда git revert отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда git reset.

У команды revert есть два крупных преимущества по сравнению с reset. Во-первых, она не меняет историю проекта и производит операцию, безопасную для коммитов. Во-вторых, её объектом выступает конкретный коммит, созданный в любой момент истории, а git reset всегда берёт за точку отсчёта текущий коммит. К примеру, если нужно отменить старый коммит с помощью git reset, придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно. Следовательно, команда git revert — гораздо более удобный и безопасный способ отмены изменений.

 # Откат заданного коммита

Откатить проект до заданного коммита можно с помощью параметра revert и идентификатора коммита. Создастся новый коммит — копия коммита с предоставленным идентификатором — и добавится к истории текущей ветки.

*git revert добавляем сюда хэш*

# Удаление изменений из индекса: Команда git reset.

Действие команды git reset <коммит> состоит из трёх потенциальных шагов:

* Переместить указатель HEAD на <коммит> (например, при откате коммита в рабочей директории и области подготовленных файлов будут более новые версии файлов, чем в HEAD). Также указатель HEAD ветки будет перемещён на этот коммит.
* Обновить область подготовленных файлов содержимым коммита. В таком случае только в рабочей директории будут новейшие версии файлов.
* Обновить рабочую директорию содержимым области подготовленных файлов. С этим нужно быть осторожнее, поскольку в итоге будут уничтожены изменения файлов.

По умолчанию команда git reset выполняет только шаги 1 и 2, однако её поведение можно изменить с помощью опций --soft (только 1 шаг) и --hard (все шаги).

*git reset* --> убрать из индекса все добавленные в него изменения (в рабочей директории все изменения сохранятся), антипод git add

*git reset readme.txt* --> убрать из индекса изменения указанного файла (в рабочей директории изменения сохранятся)
## 3 режима команды git reset: --soft, --mixed(по умолчанию), --hard)

Сделанные изменения в репозитории по умолчанию имеют статус unstaged. Для того чтобы их закоммитить сначала вы должны добавить изменения в индекс, выполнив git add. Когда вы делаете git commit, в репозиторий будет закоммичено только то, что было в индексе.

*git reset --soft*

Возьмем для примера ветку:
- A - B - C (master)
HEAD указывает на C и индекс совпадает с C.

После выполнения git reset --soft B
HEAD будет указывать на B и изменения из коммита C будут в индексе, как будто вы их добавили командой git add. Если вы сейчас выполните git commit вы получите коммит полностью идентичный C.

*git reset --mixed* (используется по умолчанию)

Режим --mixed используется по умолчанию, т.е. git reset --mixed = git reset

Вернемся к тем же начальным условиям:
- A - B - C (master)

Выполнив git reset --mixed B или git reset B

HEAD опять же будет указывать на B, но на этот раз изменения из С не будут в индексе и если вы запустите здесь git commit ничего не произойдет т.к. ничего нет в индексе. У нас есть все изменения из С, но если запустить git status то вы увидите, что все изменения not staged. Чтобы их закоммитить нужно сначала добавить их в индекс командой git add и только после этого git commit.

*git reset --hard*

Те же самые начальные условия:
- A - B - C (master)

Последний режим --hard также как и --mixed переместит HEAD на В и очистит индекс, но в отличие от --mixed жесткий reset изменит файлы в вашей рабочей директории. Если выполнить
git reset --hard B то изменения из С, равно как и незакоммиченные изменения, будут удалены и файлы в репозитории будут совпадать с B. Учитывая то, что этот режим подразумевает потерю изменений, вы всегда должны проверять git status перед тем как выполнить жесткий reset чтобы убедиться что нет незакоммиченных изменений (или же они не нужны).

# Отмена изменений

``` bash
git checkout text.txt      # ОПАСНО: отменить изменения в файле, вернуть состояние файла, имеющееся в индексе
git reset --hard           # ОПАСНО: отменить изменения; вернуть то, что в коммите, на который указывает HEAD (незакомиченные изменения удалены из индекса и из рабочей директории, неотслеживаемые файлы останутся на месте)
git clean -df              # удалить неотслеживаемые файлы и директории
```

**Все команды, приведённые ниже можно выполнять ТОЛЬКО если коммиты еще не были отправлены в удалённый репозиторий.**

``` bash
# ВНИМАНИЕ! Опасные команды, можно потерять незакоммиченные изменения
git commit --amend -m "Название"  # «перекоммитить» изменения последнего коммита, заменить его новым коммитом с другим сообщением (сдвинуть текущую ветку на один коммит назад, сохранив рабочую директорию и индекс «как есть», создать новый коммит с данными из «отменяемого» коммита, но новым сообщением)
git reset --hard @~      # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию и индекс сделать такими, какими они были в момент предыдущего коммита
git reset --hard 75e2d51 # передвинуть HEAD (и ветку) на коммит с указанным хешем, рабочую директорию и индекс сделать такими, какими они были в момент указанного коммита
git reset --soft @~      # передвинуть HEAD (и ветку) на предыдущий коммит, но в рабочей директории и индексе оставить все изменения
git reset --soft @~2     # то же, но передвинуть HEAD (и ветку) на 2 коммита назад
git reset @~             # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию оставить как есть, индекс сделать таким, каким он был в момент предыдущего коммита (удобнее, чем git reset --soft @~, если индекс нужно задать заново)
# Почти как git reset --hard, но безопаснее: не получится потерять изменения в рабочей директории
git reset --keep @~      # передвинуть HEAD (и ветку) на предыдущий коммит, сбросить индекс, но в рабочей директории оставить изменения, если возможно (если файл с изменениями между коммитами менялся, будет выдана ошибка и переключение не произойдёт)
```
# Разное:
### Кто написал строку:

``` bash
git blame README.md --date=short -L 5,8 # показать строки 5-8 указанного файла и коммиты, в которых строки были добавлены
```
### Создать архив с проектом:

``` bash
git archive -o ./project.zip HEAD # создать архив с файловой структурой проекта по указанному пути (состояние репозитория, соответствующее указателю HEAD)
```
# Дополнительно:
**Бесплатный курс по GIT и Github из 6 уроков c развернытыми статьями и практическими заданиями:**

https://smartiqa.ru/courses/git

**Видеокурс на Youtube -**
**подробно, от простого к сложному, с детальными объяснениями:**

https://www.youtube.com/playlist?list=PLDyvV36pndZFHXjXuwA_NywNrVQO0aQqb
