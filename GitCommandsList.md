# Общая информация - что такое система контроля версий Git:

Git — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит). Важно: добавление файлов к «сохранению» двухступенчатое: сначала добавляем файл в индекс (git add), потом «сохраняем» (git commit).

Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).

1. Отслеживаемый.(tracked)

Об этих файлах Git знает и отслеживает изменения в них. Отслеживаемые файлы в свою очередь могут находится в следующих состояниях:

* Неизмененный.(unmodified) То есть с момента последнего коммита в файле не было никаких изменений

* Измененный.(modified) То есть с последнего коммита в файле были произведены какие-то изменения.

* Подготовленный к коммиту.(staged) Это значит, что вы внесли изменения в этот файл и затем проиндексировали их, и эти изменения будут добавлены в следующий коммит.

2. Неотслеживаемый.(untracked)

О неотслеживаемых файлах Git не знает, поэтому изменения в них не будут добавлены в коммит. Это любые файлы в вашем рабочем каталоге, которые не входили в последний коммит и не подготовлены к текущему коммиту.

[Наглядная визуализация состояний файлов и переходов между ними.](Project_Images/1_Git_file_statuses.png)

**Ключ к пониманию концепции git — знание о трех разделах:**

[Git отслеживает файлы в трёх основных разделах:](Project_Images/Git_Project_directories.png)

* Рабочая директория - Working directory. Это файловая структура, с которой непосредственно работает пользователь в конкретный момент времени. Технически же - это копия определенной версии вашего проекта, которую вы извлекли из базы Git и в которую пытаетесь внести свои изменения.

* Индекс или Область подготовленных файлов - Index / Staging area. Это область, где хранятся имена файлов и изменения в них, которые должны войти в следующий коммит. Технически индекс - это просто файл.

* Директория Git - Git Directory. Папка, в которой Git хранит все версии вашего проекта и также свои служебные файлы. Данная папка носит название .git и располагается в корневой директории вашего проекта. [Это та самая скрытая папка .git.](Project_Images/GitFolder.png)

Все основные команды по работе с файлами сводятся к пониманию того, как Git управляет этими тремя разделами. Существует распространённое заблуждение, что область подготовленных файлов только хранит изменения. Лучше думать об этих трёх разделах как об отдельных файловых системах, каждая из которых содержит свои копии файлов. 

[Файловая система Git - тык и смотри пояснения ниже](Project_Images/git_workflow.png) 

```Развернутый комментарий к схеме разделов Git:```

1. Working derictory - изначальные файлы, с которыми вы работаете на вашем компьютере
2. Применяем команду *git add* , то есть просим Git проиндексировать файлы и начать наблюдать за ними.
3. Staging area - наши файлы оказались списке отслеживаемых git-ом файлов и директорий. Иными словами этот раздел представляет собой обычный файл, обычно хранящийся в каталоге Git, который содержит информацию о том, что должно войти в следующий коммит. Иногда его называют индексом (index), но в последнее время становится стандартом называть его областью подготовленных файлов.
4. Мы фиксируем (*git commit*) финальное или промежуточное состояние наших файлов (делаем точку сохранения с которой патом сможем продолжить, по аналогии с играми)
5. Local Repository - зафиксированные файлы оказываются в локальном репозитории Локальный репозиторий - это репозиторий, который хранится на нашем компьютере, в рабочей папке проекта. [Это та самая скрытая папка .git.](Project_Images/GitFolder.png)

Пройдя выше упомянутый путь мы сможем работать с удалённым репозиторием Remote repository (например GitHub) отправлять туда информацию (push) и брать оттуда информацию в наш локальный репозиторий (pull).

*Получаем простейший цикл нашего рабочего процесса:*

* Редактирование, добавление, удаление файлов (собственно, работа). 

* Индексация/добавление файлов в индекс (указание для git какие изменения нужно будет закоммитить).

* Коммит (фиксация изменений).

* Возврат к шагу 1 или завершение работы

**Указатели:**

*Немного про указатели*
Указатель – это ссылка на определенный коммит или ветку. А ссылка – это некоторая метка, которую использует Git или сам пользователь, чтобы указать на коммит или ветку. И как мы уже сказали, физически ветки – самые настоящие указатели ведь они указывают на коммит. При добавлении коммита, указатель ветки перемещается с родительского коммита на новый. 

**Давайте приведем примеры еще некоторых часто используемых указателей:**

* HEAD – так называемый курсор Git. Главное назначение HEAD - определять, в каком состоянии находится рабочая копия (напомним, что рабочая копия – это все файлы репозитория, за исключением директории .git/). На какой коммит указывает HEAD – из того коммита и загружаются файлы в рабочую директорию.
* ORIG_HEAD – указатель, который появляется, когда мы вручную передвигаем HEAD на какой-нибудь НЕ последний коммит. ORIG_HEAD указывает на тот же коммит, на который указывал HEAD до передвижения назад. Нужен он, чтобы мы имели возможность вернуться на хронологически последний коммит без существенных затрат (в истории мы не будем видеть все коммиты старше нашего, а поэтому не сможем узнать хэш последнего).
* Пользовательские указатели.(Теги, комментарии) Пользователи сами могут создавать указатели. Например, вы можете создать указатель version-1.2.1, который будет указывать на коммит, в котором хранится версия 1.2.1 вашего проекта. Это довольно удобно, поскольку вы можете переключаться на коммит с той или иной версией, не запоминая его хэш.

Преимущество веток в их независимости. Вы можете вносить изменения в файлы в одной ветке, например, пробовать новую функцию, и они никак не скажутся на файлах в другой ветке. Изначально в репозитории одна ветка, но позже мы рассмотрим, как создавать другие.

На самом деле, вначале, когда мы делаем свой первый коммит, Git автоматически создает основную ветку. Вы можете помнить, что ее имя по умолчанию "main" мы задавали в настройках Git в предыдущем уроке. Каждый раз, когда мы создаем новый коммит, Git автоматически перемещает указатель main на последний коммит

[Представление веток внутри Git](Project_Images/BranchesStructure.webp)

На рисунке овалы с хэшами – наши коммиты, main – ветка по умолчанию и в то же время указатель на коммит 62aa, а HEAD – указатель на ветку, с которой мы сейчас работаем, то есть на ветку main.
# Первостепенные команды после установки Git на компьтер:

Первое, что вам следует сделать после установки Git — указать ваше имя и адрес электронной почты. Это важно, потому что каждый коммит в Git содержит эту информацию, и она включена в коммиты, передаваемые вами, и не может быть далее изменена после начала работы над проектом и осуществления комиттов:

*   *git config --global user.name "Name"*

*   *git config --global user.email yourname@example.com*

После указания своих данных, можно их просмотреть:

* *git config --global --list*

Чтобы установить имя main для вашей ветки по умолчанию, выполните следующую команду:

*  *git config --global init.defaultBranch main*

Имя главной ветки может быть любым, но для оптимизации работы есть правила хорошего тона которые следуетс соблюдать в зависимости от требований и желаний участников рабочего процесса... Так например, с 2020 года GitHub выступает за то, чтобы главная ветка называлась main (по политическим причинам) и настоятельно рекомендует переименовать ветку

# Инициализация репозитория:

Создать пустой репозиторий Git или вновь инициализировать существующий можно параметром init. При инициализации он создаст [скрытую папку.](Project_Images/GitFolder.png) В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.

* *git init*

# Определение состояния файлов:

Команда git status отображает все файлы, которые различаются между тремя разделами. 
У файлов есть 4 состояния:
* Неотслеживаемый (untracked) — находится в рабочей директории, но нет ни одной версии в HEAD или в области подготовленных файлов (Git не знает о файле).
* Изменён (modified) — в рабочей директории есть более новая версия по сравнению с хранящейся в HEAD или в области подготовленных файлов (изменения не находятся в следующем коммите).
* Подготовлен (staged) — в рабочей директории и области подготовленных файлов есть более новая версия по сравнению с хранящейся в HEAD (готов к коммиту).
* Без изменений — одна версия файла во всех разделах, т. е. в последнем коммите содержится актуальная версия.

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда :

* *git status*

Файл может быть одновременно в состоянии «изменён» и «подготовлен», если версия в рабочей директории новее, чем в области подготовленных файлов, которая в свою очередь новее версии в HEAD. Мы можем использовать опцию -s для команды git status, чтобы получить более компактный вывод (по строке на файл). Если файл не отслеживается, то будет выведено что он не отслеживается; если он был изменён, то его имя будет красным, а если подготовлен — зелёным.

# Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл:
* *git add*
* *git add .*  --> добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий
* *git add -A* или *git add --all*--> добавляем все измененные файлы в индекс:

[Команда git add. Добавление новых изменений файла в индекс.](Project_Images/change_and_add_fil.png)
# Удаление файлов:

* *git rm <имя файла>* - отменяет отслеживание файла и удаляет его из рабочей директории иными словами удаляет отслеживаемый неизменённый файл и проиндексирует это изменение
* *git rm -f <имя файла>* - удалить отслеживаемый изменённый файл и проиндексировать это изменение
* *git rm -r log/* - удалить всё содержимое отслеживаемой директории log/ и проиндексировать это изменение
* *git rm ind*\*  - удалить все отслеживаемые файлы с именем, начинающимся на «ind» в текущей директории и проиндексировать это изменение
* *git rm --cached <имя файла>* - удалить из отслеживаемых индексированный файл (ФАЙЛ ОСТАНЕТСЯ НА МЕСТЕ) (часто используется для нечаянно добавленных в отслеживаемые файлов)

**Пример:**

Удалим файл sample.txt из рабочей копии и индекса: -->  *git rm sample.txt*

Удалим файл sample.txt из индекса и перемеcтим его в категорию Untracked --> *git rm --cached sample.txt*

[Удаляйте файлы через Git правильно](Project_Images/GitHowToDeleteCorrectly.png)

# Восстановление файлов после удаления:

Если мы захотим восстановить файл после удаления или изменения в рабочей копии или индексе - для этого существует команда *git restore.*

*git restore <ключ> <имя файла>* 

**Ключи**
*-s, --source=<tree>* --> Этот ключ нужен, чтобы передать команде путь к коммиту (ветке, пользовательскому указателю), откуда мы будем восстанавливать файл. По умолчанию файл берется из области индекса.

*--worktree* (англ. рабочая копия)
*--staged* (англ. область индекса)

Эти два ключа позволяют указать, где именно восстанавливать файл. По умолчанию, если ни один из этих двух ключей не передан, файл восстанавливается только в рабочей копии.

Если же передан ключ --staged, файл восстанавливается только в области индекса. В этом случае источником восстановления по умолчанию является коммит, на который указывает HEAD (поскольку мы не можем восстановить файл в области индекса из самой же области индекса).

Если же вы хотите восстановить файл и в рабочей копии, и в области индекса, вам нужно передать оба ключа.

**Примеры:**

Если вы случайно удалили файл sample.txt обычным способом, то можно восстановить его из индекса --> *git restore sample.txt*

Вернем файл sample.txt к определенному коммиту с хэшем 09c2240. При этом мы изменим только файл в рабочей копии, файл в области индекса не поменяется.
--> *git restore --source 09c2240 sample.txt*

Вернем файл sample.txt в индексе к состоянию последнего коммита (отменим все внесенные изменения или удалим файл, если в предыдущем коммите его не было), при этом изменения коснутся только индекса файла, рабочая копия не поменяется.
--> *git restore --staged sample.txt*

Сделаем то же, что и в предыдущем примере, но теперь изменения затронут и файл в рабочей копии.
--> *git restore --staged --worktree sample.txt*

# Игнорирование файлов:

Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.). В таком случае, вы можете создать файл c названием .gitignore. с перечислением шаблонов соответствующих таким файлам. Для сопоставления с именами файлов в .gitignore используются шаблоны подстановки. С помощью различных символов можно создавать собственные шаблоны. 
Чтобы отметить файлы, которые мы хотим игнорировать, можно использовать эти шаблоны поиска (считайте их упрощёнными регулярными выражениями):

* /___ — позволяет избежать рекурсивности — соответствует файлам только в текущей директории;
* __/ — соответствует всем файлам в указанной директории;
* ___ — соответствует всем файлам с указанным окончанием;
* ! — игнорирование файлов, попадающих под указанный шаблон;
* [__] — соответствует любому символу из указанных в квадратных скобках;
* ? — соответствует любому символу;
* /**/ — соответствует вложенным директориям, например a/\*\*/d соответствует a/d, a/b/d, a/b/c/d и т. д.
Мы даже можем использовать шаблоны поиска при указании файла/папки в других командах. Например, git add src/*.css добавит все файлы .css в папке src.

[Подробное описание в документации пректа на стр 32](Project_Documentation/progit.pdf)

# Внесение изменений однострочным сообщением или через редактор - git commit:

Команда git commit откроет [текстовый редактор](VimTextRedactorSummary.md) для ввода сообщения коммита. Также эта команда принимает несколько аргументов:

* -m позволяет написать сообщение вместе с командой, не открывая редактор. 
 *git commit -m "Залил фотку Тефтельки"*
* -a переносит все отслеживаемые файлы в область подготовленных файлов и включает их в коммит (позволяет пропустить git add перед коммитом);
*git commit -a "Залил фотку Тефтельки"*
* --amend заменяет последний коммит новым изменённым коммитом, что бывает полезно, если вы неправильно набрали сообщение последнего коммита или забыли включить в него какие-то файлы.
*git commit --amend -m "Залил фотку Тефтельки - я молодец!"*

Коммиты хранят состояние файловой системы в определённый момент времени и указатели на предыдущие коммиты. Каждый коммит содержит уникальную контрольную сумму — идентификатор, который Git использует, чтобы ссылаться на коммит. Чтобы отслеживать историю, Git хранит указатель HEAD, который указывает на первый коммит (мы следуем по цепочке коммитов в обратном порядке, чтобы попасть к предыдущим коммитам).
[Историю коммитов визуально можно отобразить так](Project_Images/commit-history-970x386.webp)

* Коммитьте как можно чаще.
* Одно изменение — один коммит: не помещайте все не связанные между собой изменения в один коммит, разделите их, чтобы было проще откатиться.
* Формат сообщений: заголовок должен быть в повелительном наклонении, меньше 50 символов в длину и должен логически дополнять фразу this commit will ___(this commit will fix bugs — этот коммит исправит баги). Сообщение должно пояснять, почему был сделан коммит, а сам коммит показывает, что изменилось.
* Если у вас много незначительных изменений, хорошим тоном считается делать небольшие коммиты при разработке, а при добавлении в большой репозиторий объединять их в один коммит.

# Просмотр истории коммитов с изменениями

Просматривать изменения, внесённые в репозиторий, можно с помощью параметра log. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг -p, вы можете подробно изучить изменения, внесённые в конкретный файл.

* *git log*  - общий журнал всех изменений
* *git log -p имя файла.расширение* - список изменений для внесённых в конкретный файл.
* *git log --graph* - история в виде дерева (Выводит коммиты в виде дерева, в командной строке псевдографикой. Плюс выводит список измененных файлов.)
* *git log --oneline*- выводит журнал форме короткого списка c комметариями коммитов и хешем из первых 7 символов 
[Это очень полезная команда](Project_Images/GitLogOneLine.png)
# Просмотр заданного коммита:

Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра show, указав идентификатор или хеш коммита. Значение хеша уникально для каждого коммита, созданного в вашем репозитории.

* *git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29*

Также можно использовать сокращённый хеш:

* *git show 1af1*

Также можно увидеть более подробную информацию о коммите и узнать кто автор изменений, а кто сделал сам коммит(без хеша выводит информацию по последнему коммиту):

* *git show --pretty=fuller*

# Для переключения на нужный коммит 

Используется действие checkout.После переключения, все файлы в проекте станут такими, какими они были в данном коммите.

* *git checkout commit*

*Где commit - это хеш (обозначение, имя) коммита, причем можно указывать не весь хеш, а несколько начальных символов хеша (4 первых символа как правило достаточно)*

# Возвращаемся к основной ветке

* *git checkout master*  __or__  *git checkout main*

# Сравнение с последним коммитом

Для вывода изменений в файлах по сравнению с последним коммитом, используется git diff без параметров Команда выводит изменения в файлах, которые еще не были добавлены в индекс. Сравнение происходит с последним коммитом.

* *git diff*

# Ветвления:
Ветка – независимая последовательность коммитов. Ветки нужны, чтобы тестировать новые функции и распараллеливать работу над проектом.
Первоначально мы работаем в основной ветке. У нас она называется main.
Обычно в основной ветке находится та же версия кода, что и в продакшене. То есть если в основную ветку попадут какие-то непроверенные изменения, код может сломаться и повлечь за собой поломку приложения у конечного пользователя. Поэтому во всех командах, работающих над серьезными проектами, принято, что в основной ветке находятся только протестированные изменения, которые в идеале не придется экстренно исправлять.

То есть общий ход нашей работы выглядит следующим образом:

1. Решили добавить новую функцию – создали отдельную ветку. Дальше работаем в новой ветке.
2. Написали функцию, протестировали ее работу, внесли все необходимые исправления, еще раз протестировали и убедились, что функция работает исправно и не привнесла ошибок в остальной код.
3. Теперь нужно как-то перенести изменения с тестовой ветки на основную – в продакшн. Тут нам на помощь и приходит слияние: мы просто сливаем (т.е. переносим) изменения с нашей тестовой ветки в основную.

* Создание ветки:

*git branch Имя_ветки*

* Переключение между ветками:

*git checkout Имя_ветки*

* Создание ветки и сразу переключение на неё:

*git checkout –b Имя_ветки*

* Переименование ветки:

*git branch –m Старое_название_ветки Новое_название_ветки*

* Удаление ветки:

Удалить ветку можно параметром branch с добавлением флага -d и указанием имени ветки. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.

*git branch –d Имя_ветки*

Для принудительного удаления ветки используется флаг -D с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.

*git branch –D Имя_ветки*

 # Алгоритм cлияния веток:

1. Переключиться на ветку, в которой будут приняты изменения:

*git checkout Имя_ветки*

2. Указать ветку, в которой будут приняты изменения:

*git merge ветка_с_нужными_изменениями*

# Конфликты:

Для того, чтобы выяснить, в каких файлах есть конфликты, нужно набрать Git команду: *git status*
Все, что находится в HEAD - это наши изменения, и все, что находится после знаков равно (======)- это внешние изменения.    

[Вот как это выглядит](Project_Images/merge.png)

Вам нужно выбрать, какие изменения оставить.

После того как решите конфликты, нужно использовать Git команду: *git commit*

# Прекращение слияния веток при конфликте

Прервать слияние в случае конфликта можно параметром merge с флагом --abort. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.

* *git merge --abort*

# Откат коммитов. Команда git revert.

Пожалуй одна из самых важных частей в изучении Git – научиться откатываться к предыдущим коммитам. Смысл отката мы обсуждали в предыдущих уроках: ваш проект может перестать работать по непонятным вам причинам после внесения некоторых изменений в код, в таком случае важно быстро вернуть все к рабочему состоянию и только потом заниматься поиском ошибки. В этом-то случае нам и поможет откат коммитов и команда git revert.Все коммиты, которые уже были отправлены в удалённый репозиторий, должны отменяться новыми коммитами (git revert), дабы избежать проблем с историей разработки у других участников проекта.

    git revert HEAD  --> создать новый коммит, отменяющий изменения последнего коммита 

*git revert HEAD --no-edit*  --> создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения

*git revert b9533bb --no-edit*  --> то же что и выше, но отменяются изменения, внесённые коммитом с указанным хешем (b9533bb)

*git revert HEAD~2* -->  отменяются изменения, внесенные 2 коммита назад

*git revert HEAD~5..HEAD~2* --> отменяются изменения, начиная с пятого с конца и заканчивая вторым с конца.

**Разница между revert и reset**

Команда git revert отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда git reset.

У команды revert есть два крупных преимущества по сравнению с reset. Во-первых, она не меняет историю проекта и производит операцию, безопасную для коммитов. Во-вторых, её объектом выступает конкретный коммит, созданный в любой момент истории, а git reset всегда берёт за точку отсчёта текущий коммит. К примеру, если нужно отменить старый коммит с помощью git reset, придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно. Следовательно, команда git revert — гораздо более удобный и безопасный способ отмены изменений.

 # Откат заданного коммита

Откатить проект до заданного коммита можно с помощью параметра revert и идентификатора коммита. Создастся новый коммит — копия коммита с предоставленным идентификатором — и добавится к истории текущей ветки.

*git revert добавляем сюда хэш*

# 3 режима команды git reset: --soft, --mixed(по умолчанию), --hard)

Сделанные изменения в репозитории по умолчанию имеют статус unstaged. Для того чтобы их закоммитить сначала вы должны добавить изменения в индекс, выполнив git add. Когда вы делаете git commit, в репозиторий будет закоммичено только то, что было в индексе.

*git reset --soft*

Возьмем для примера ветку:
- A - B - C (master)
HEAD указывает на C и индекс совпадает с C.

После выполнения git reset --soft B
HEAD будет указывать на B и изменения из коммита C будут в индексе, как будто вы их добавили командой git add. Если вы сейчас выполните git commit вы получите коммит полностью идентичный C.

*git reset --mixed* (используется по умолчанию)

Режим --mixed используется по умолчанию, т.е. git reset --mixed = git reset

Вернемся к тем же начальным условиям:
- A - B - C (master)

Выполнив git reset --mixed B или git reset B

HEAD опять же будет указывать на B, но на этот раз изменения из С не будут в индексе и если вы запустите здесь git commit ничего не произойдет т.к. ничего нет в индексе. У нас есть все изменения из С, но если запустить git status то вы увидите, что все изменения not staged. Чтобы их закоммитить нужно сначала добавить их в индекс командой git add и только после этого git commit.

*git reset --hard*

Те же самые начальные условия:
- A - B - C (master)

Последний режим --hard также как и --mixed переместит HEAD на В и очистит индекс, но в отличие от --mixed жесткий reset изменит файлы в вашей рабочей директории. Если выполнить
git reset --hard B то изменения из С, равно как и незакоммиченные изменения, будут удалены и файлы в репозитории будут совпадать с B. Учитывая то, что этот режим подразумевает потерю изменений, вы всегда должны проверять git status перед тем как выполнить жесткий reset чтобы убедиться что нет незакоммиченных изменений (или же они не нужны).

Это значит что:

Действие команды git reset <коммит> состоит из трёх потенциальных шагов:

* Переместить указатель HEAD на <коммит> (например, при откате коммита в рабочей директории и области подготовленных файлов будут более новые версии файлов, чем в HEAD). Также указатель HEAD ветки будет перемещён на этот коммит.
* Обновить область подготовленных файлов содержимым коммита. В таком случае только в рабочей директории будут новейшие версии файлов.
* Обновить рабочую директорию содержимым области подготовленных файлов. С этим нужно быть осторожнее, поскольку в итоге будут уничтожены изменения файлов.

По умолчанию команда git reset выполняет только шаги 1 и 2, однако её поведение можно изменить с помощью опций --soft (только 1 шаг) и --hard (все шаги).

# Шпаргалка по GIT:
https://github.com/cyberspacedk/Git-commands

# Дополнительно:
**бесплатный курс по GIT и Github из 6 уроков c развернытыми статьями и практическими заданиями:**

https://smartiqa.ru/courses/git

**Видеокурс на Youtube -**
**подробно, от простого к сложному, с детальными объяснениями:**

https://www.youtube.com/playlist?list=PLDyvV36pndZFHXjXuwA_NywNrVQO0aQqb
