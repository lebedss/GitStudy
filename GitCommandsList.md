# Общее: 
Git — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит). Важно: добавление файлов к «сохранению» двухступенчатое: сначала добавляем файл в индекс (git add), потом «сохраняем» (git commit). Не забываем сохранить у себя на компьтере изменения прежде чем обращаться к Git...

Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).

Отслеживаемые файлы могут быть в 3-х состояниях: неизменённые, изменённые, проиндексированные (готовые к коммиту).

__Ключ к пониманию концепции git — знание о «трех деревьях»:__

Git отслеживает файлы в трёх основных разделах:

* рабочая директория (файловая система проекта на вашем компьютере - те файлы, с которыми вы работаете);

* область подготовленных файлов. Индекс — список отслеживаемых git-ом файлов и директорий, промежуточное хранилище изменений (редактирование, удаление отслеживаемых файлов).
Директория .git/ — все данные контроля версий этого проекта (вся история разработки: коммиты, ветки, теги и пр.).

* HEAD (последний коммит в репозитории). Коммит — «сохранение» (хранит набор изменений, сделанный в рабочей директории с момента предыдущего коммита). Коммит неизменен, его нельзя отредактировать.

Все основные команды по работе с файлами сводятся к пониманию того, как Git управляет этими тремя разделами. Существует распространённое заблуждение, что область подготовленных файлов только хранит изменения. Лучше думать об этих трёх разделах как об отдельных файловых системах, каждая из которых содержит свои копии файлов.

[Файловая система Git](Project_Images/file-system-git-970x728.webp)

*Простейший цикл работ:*

* Редактирование, добавление, удаление файлов (собственно, работа). 

* Индексация/добавление файлов в индекс (указание для git какие изменения нужно будет закоммитить).

* Коммит (фиксация изменений).

* Возврат к шагу 1 или отход ко сну.

_Указатели:_

* HEAD — указатель на текущий коммит или на текущую ветку (то есть, в любом случае, на коммит). Указывает на родителя коммита, который будет создан следующим.

* ORIG_HEAD — указатель на коммит, с которого вы только что переместили HEAD (командой git reset ..., например).

* Ветка (master, develop etc.) — указатель на коммит. При добавлении коммита, указатель ветки перемещается с родительского коммита на новый.

* Теги — простые указатели на коммиты. Не перемещаются.

# Первостепенные команды после установки Git на компьтер:

Первое, что вам следует сделать после установки Git — указать ваше имя и адрес электронной почты. Это важно, потому что каждый коммит в Git содержит эту информацию, и она включена в коммиты, передаваемые вами, и не может быть далее изменена после начала работы над проектом и осуществления комиттов:

*   *git config --global user.name "Name"*

*   *git config --global user.email yourname@example.com*

После указания своих данных, можно их просмотреть:

* *git config --global --list*

Чтобы установить имя main для вашей ветки по умолчанию, выполните следующую команду:

*  *git config --global init.defaultBranch main*

Имя главной ветки может быть любым, но для оптимизации работы есть правила хорошего тона которые следуетс соблюдать в зависимости от требований и желаний участников рабочего процесса... Так например, с 2020 года GitHub выступает за то, чтобы главная ветка называлась main (по политическим причинам) и настоятельно рекомендует переименовать ветку

# Инициализация репозитория:

Создать пустой репозиторий Git или вновь инициализировать существующий можно параметром init. При инициализации он создаст [скрытую папку.](Project_Images/GitFolder.png) В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.

* *git init*

# Определение состояния файлов:

Команда git status отображает все файлы, которые различаются между тремя разделами. 
У файлов есть 4 состояния:
* Неотслеживаемый (untracked) — находится в рабочей директории, но нет ни одной версии в HEAD или в области подготовленных файлов (Git не знает о файле).
* Изменён (modified) — в рабочей директории есть более новая версия по сравнению с хранящейся в HEAD или в области подготовленных файлов (изменения не находятся в следующем коммите).
* Подготовлен (staged) — в рабочей директории и области подготовленных файлов есть более новая версия по сравнению с хранящейся в HEAD (готов к коммиту).
* Без изменений — одна версия файла во всех разделах, т. е. в последнем коммите содержится актуальная версия.

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда :

* *git status*

Файл может быть одновременно в состоянии «изменён» и «подготовлен», если версия в рабочей директории новее, чем в области подготовленных файлов, которая в свою очередь новее версии в HEAD. Мы можем использовать опцию -s для команды git status, чтобы получить более компактный вывод (по строке на файл). Если файл не отслеживается, то будет выведено что он не отслеживается; если он был изменён, то его имя будет красным, а если подготовлен — зелёным.

# Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл:
* *git add*
* *git add .*  --> добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий

# Удаление файлов:

* *git rm <имя файла>* - отменяет отслеживание файла и удаляет его из рабочей директории иными словами удаляет отслеживаемый неизменённый файл и проиндексирует это изменение
* *git rm -f <имя файла>* - удалить отслеживаемый изменённый файл и проиндексировать это изменение
* *git rm -r log/* - удалить всё содержимое отслеживаемой директории log/ и проиндексировать это изменение
* *git rm ind*\*  - удалить все отслеживаемые файлы с именем, начинающимся на «ind» в текущей директории и проиндексировать это изменение
* *git rm --cached <имя файла>* - удалить из отслеживаемых индексированный файл (ФАЙЛ ОСТАНЕТСЯ НА МЕСТЕ) (часто используется для нечаянно добавленных в отслеживаемые файлов)

# Игнорирование файлов:

Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.). В таком случае, вы можете создать файл c названием .gitignore. с перечислением шаблонов соответствующих таким файлам. Для сопоставления с именами файлов в .gitignore используются шаблоны подстановки. С помощью различных символов можно создавать собственные шаблоны. 
Чтобы отметить файлы, которые мы хотим игнорировать, можно использовать эти шаблоны поиска (считайте их упрощёнными регулярными выражениями):

* /___ — позволяет избежать рекурсивности — соответствует файлам только в текущей директории;
* __/ — соответствует всем файлам в указанной директории;
* ___ — соответствует всем файлам с указанным окончанием;
* ! — игнорирование файлов, попадающих под указанный шаблон;
* [__] — соответствует любому символу из указанных в квадратных скобках;
* ? — соответствует любому символу;
* /**/ — соответствует вложенным директориям, например a/\*\*/d соответствует a/d, a/b/d, a/b/c/d и т. д.
Мы даже можем использовать шаблоны поиска при указании файла/папки в других командах. Например, git add src/*.css добавит все файлы .css в папке src.

[Подробное описание в документации пректа на стр 32](Project_Documentation/progit.pdf)

# Внесение изменений однострочным сообщением или через редактор - git commit:

Команда git commit откроет текстовый редактор для ввода сообщения коммита. Также эта команда принимает несколько аргументов:

* -m позволяет написать сообщение вместе с командой, не открывая редактор. 
 *git commit -m "Залил фотку Тефтельки"*
* -a переносит все отслеживаемые файлы в область подготовленных файлов и включает их в коммит (позволяет пропустить git add перед коммитом);
*git commit -a "Залил фотку Тефтельки"*
* --amend заменяет последний коммит новым изменённым коммитом, что бывает полезно, если вы неправильно набрали сообщение последнего коммита или забыли включить в него какие-то файлы.
*git commit --amend -m "Залил фотку Тефтельки - я молодец!"*

Коммиты хранят состояние файловой системы в определённый момент времени и указатели на предыдущие коммиты. Каждый коммит содержит уникальную контрольную сумму — идентификатор, который Git использует, чтобы ссылаться на коммит. Чтобы отслеживать историю, Git хранит указатель HEAD, который указывает на первый коммит (мы следуем по цепочке коммитов в обратном порядке, чтобы попасть к предыдущим коммитам).
[Историю коммитов визуально можно отобразить так](Project_Images/commit-history-970x386.webp)

* Коммитьте как можно чаще.
* Одно изменение — один коммит: не помещайте все не связанные между собой изменения в один коммит, разделите их, чтобы было проще откатиться.
* Формат сообщений: заголовок должен быть в повелительном наклонении, меньше 50 символов в длину и должен логически дополнять фразу this commit will ___(this commit will fix bugs — этот коммит исправит баги). Сообщение должно пояснять, почему был сделан коммит, а сам коммит показывает, что изменилось.
* Если у вас много незначительных изменений, хорошим тоном считается делать небольшие коммиты при разработке, а при добавлении в большой репозиторий объединять их в один коммит.

# Просмотр истории коммитов с изменениями

Просматривать изменения, внесённые в репозиторий, можно с помощью параметра log. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг -p, вы можете подробно изучить изменения, внесённые в конкретный файл.

* *git log*  - общий журнал всех изменений
* *git log -p имя файла.расширение* - список изменений для внесённых в конкретный файл.
* *git log --graph* - история в виде дерева (Выводит коммиты в виде дерева, в командной строке псевдографикой. Плюс выводит список измененных файлов.)
* *git log --oneline* выводит журнал с хешем и комитами в форме короткого списка
# Просмотр заданного коммита:

Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра show, указав идентификатор или хеш коммита. Значение хеша уникально для каждого коммита, созданного в вашем репозитории.

* *git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29*

Также можно использовать сокращённый хеш:

* *git show 1af1*

# Для переключения на нужный коммит 

Используется действие checkout.После переключения, все файлы в проекте станут такими, какими они были в данном коммите.

* *git checkout commit*

*Где commit - это хеш (обозначение, имя) коммита, причем можно указывать не весь хеш, а несколько начальных символов хеша (4 первых символа как правило достаточно)*

# Возвращаемся к основной ветке

* *git checkout master*  __or__  *git checkout main*

# Сравнение с последним коммитом

Для вывода изменений в файлах по сравнению с последним коммитом, используется git diff без параметров Команда выводит изменения в файлах, которые еще не были добавлены в индекс. Сравнение происходит с последним коммитом.

* *git diff*

# Ветвления:

* Создание ветки:

*git branch Имя_ветки*

* Переключение между ветками:

*git checkout Имя_ветки*

* Создание ветки и сразу переключение на неё:

*git checkout –b Имя_ветки*

* Переименование ветки:

*git branch –m Старое_название_ветки Новое_название_ветки*

* Удаление ветки:

Удалить ветку можно параметром branch с добавлением флага -d и указанием имени ветки. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.

*git branch –d Имя_ветки*

Для принудительного удаления ветки используется флаг -D с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.

*git branch –D Имя_ветки*

 # Алгоритм cлияния веток:

1. Переключиться на ветку, в которой будут приняты изменения:

*git checkout Имя_ветки*

2. Указать ветку, в которой будут приняты изменения:

*git merge ветка_с_нужными_изменениями*

# Конфликты:

Для того, чтобы выяснить, в каких файлах есть конфликты, нужно набрать Git команду: *git status*
Все, что находится в HEAD - это наши изменения, и все, что находится после знаков равно (======)- это внешние изменения.    

[Вот как это выглядит](Project_Images/merge.png)

Вам нужно выбрать, какие изменения оставить.

После того как решите конфликты, нужно использовать Git команду: *git commit*

# Прекращение слияния веток при конфликте

Прервать слияние в случае конфликта можно параметром merge с флагом --abort. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.

* *git merge --abort*

# Откат последнего коммита

Откатить последний коммит можно с помощью параметра revert. Создастся новый коммит, содержащий обратные преобразования относительно предыдущего, и добавится к истории текущей ветки.

*git revert HEAD*

__Разница между revert и reset__

Команда git revert отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда git reset.

У команды revert есть два крупных преимущества по сравнению с reset. Во-первых, она не меняет историю проекта и производит операцию, безопасную для коммитов. Во-вторых, её объектом выступает конкретный коммит, созданный в любой момент истории, а git reset всегда берёт за точку отсчёта текущий коммит. К примеру, если нужно отменить старый коммит с помощью git reset, придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно. Следовательно, команда git revert — гораздо более удобный и безопасный способ отмены изменений.

 # Откат заданного коммита

Откатить проект до заданного коммита можно с помощью параметра revert и идентификатора коммита. Создастся новый коммит — копия коммита с предоставленным идентификатором — и добавится к истории текущей ветки.

*git revert добавляем сюда хэш*

# 3 режима команды git reset: --soft, --mixed(по умолчанию), --hard)

Сделанные изменения в репозитории по умолчанию имеют статус unstaged. Для того чтобы их закоммитить сначала вы должны добавить изменения в индекс, выполнив git add. Когда вы делаете git commit, в репозиторий будет закоммичено только то, что было в индексе.

*git reset --soft*

Возьмем для примера ветку:
- A - B - C (master)
HEAD указывает на C и индекс совпадает с C.

После выполнения git reset --soft B
HEAD будет указывать на B и изменения из коммита C будут в индексе, как будто вы их добавили командой git add. Если вы сейчас выполните git commit вы получите коммит полностью идентичный C.

*git reset --mixed* (используется по умолчанию)

Режим --mixed используется по умолчанию, т.е. git reset --mixed = git reset

Вернемся к тем же начальным условиям:
- A - B - C (master)

Выполнив git reset --mixed B или git reset B

HEAD опять же будет указывать на B, но на этот раз изменения из С не будут в индексе и если вы запустите здесь git commit ничего не произойдет т.к. ничего нет в индексе. У нас есть все изменения из С, но если запустить git status то вы увидите, что все изменения not staged. Чтобы их закоммитить нужно сначала добавить их в индекс командой git add и только после этого git commit.

*git reset --hard*

Те же самые начальные условия:
- A - B - C (master)

Последний режим --hard также как и --mixed переместит HEAD на В и очистит индекс, но в отличие от --mixed жесткий reset изменит файлы в вашей рабочей директории. Если выполнить
git reset --hard B то изменения из С, равно как и незакоммиченные изменения, будут удалены и файлы в репозитории будут совпадать с B. Учитывая то, что этот режим подразумевает потерю изменений, вы всегда должны проверять git status перед тем как выполнить жесткий reset чтобы убедиться что нет незакоммиченных изменений (или же они не нужны).

Это значит что:

Действие команды git reset <коммит> состоит из трёх потенциальных шагов:

* Переместить указатель HEAD на <коммит> (например, при откате коммита в рабочей директории и области подготовленных файлов будут более новые версии файлов, чем в HEAD). Также указатель HEAD ветки будет перемещён на этот коммит.
* Обновить область подготовленных файлов содержимым коммита. В таком случае только в рабочей директории будут новейшие версии файлов.
* Обновить рабочую директорию содержимым области подготовленных файлов. С этим нужно быть осторожнее, поскольку в итоге будут уничтожены изменения файлов.

По умолчанию команда git reset выполняет только шаги 1 и 2, однако её поведение можно изменить с помощью опций --soft (только 1 шаг) и --hard (все шаги).
# Шпаргалка по GIT:
https://github.com/cyberspacedk/Git-commands
