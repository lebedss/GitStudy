# Первостепенные команды после установки Git

Первое, что вам следует сделать после установки Git — указать ваше имя и адрес электронной почты. Это важно, потому что каждый коммит в Git содержит эту информацию, и она включена в коммиты, передаваемые вами, и не может быть далее изменена:

*   *git config --global user.name "Name"*

*   *git config --global user.email yourname@example.com*

Чтобы установить имя main для вашей ветки по умолчанию, выполните следующую команду:

*  *git config --global init.defaultBranch main*

# Инициализация репозитория

Создать пустой репозиторий Git или вновь инициализировать существующий можно параметром init. При инициализации он создаст скрытую папку. В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.

* *git init*

# Определение состояния файлов

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда
* *git status*

# Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл
* *git add*

Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.). В таком случае, вы можете создать файл .gitignore. с перечислением шаблонов соответствующих таким файлам.

* *Создаём файл:*  **.gitignore**

# Внесение изменений однострочным сообщением или через редактор

При создании коммита в репозитории можно добавить однострочное сообщение с помощью параметра commit с флагом -m. Само сообщение вводится непосредственно после флага, в кавычках.

* *git commit -m "Your short summary about the commit"*

Также можно открыть текстовый редактор в терминале для написания полного сообщения коммита. Оно может состоять из нескольких строк текста, в котором подробно характеризуются изменения, внесённые в репозиторий.

* *git commit*

_Изменение последнего коммита:_

Внести изменения в последний коммит можно параметром commit с флагом --amend. Например, вы записали изменения, внесённые в ряд файлов, и поняли, что допустили ошибку в сообщении коммита. В этом случае можете воспользоваться указанной командой, чтобы отредактировать сообщение предыдущего коммита, не изменяя его снимок.

* *git commit --amend -m "Updated message for the previous commit"*

# Просмотр истории коммитов с изменениями

Просматривать изменения, внесённые в репозиторий, можно с помощью параметра log. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг -p, вы можете подробно изучить изменения, внесённые в каждый файл.

* *git log*
* *git log -p*
* *git log --graph*, история в виде дерева (Выводит коммиты в виде дерева, в командной строке псевдографикой. Плюс выводит список измененных файлов.))

# Просмотр заданного коммита:

Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра show, указав идентификатор или хеш коммита. Значение хеша уникально для каждого коммита, созданного в вашем репозитории.

* *git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29*

Также можно использовать сокращённый хеш:

* *git show 1af17e*

# Для переключения на нужный коммит 

Используется действие checkout.После переключения, все файлы в проекте станут такими, какими они были в данном коммите.

* *git checkout commit*

*Где commit - это хеш (обозначение, имя) коммита, причем можно указывать не весь хеш, а несколько начальных символов хеша (4 первых символа как правило достаточно)*

# Возвращаемся к основной ветке

* *git checkout master*  __or__  *git checkout main*

# Сравнение с последним коммитом

Для вывода изменений в файлах по сравнению с последним коммитом, используется git diff без параметров Команда выводит изменения в файлах, которые еще не были добавлены в индекс. Сравнение происходит с последним коммитом. Команда :

* *git diff*

# Ветвления:

* Создание ветки:

*git branch Имя_ветки*

* Переключение между ветками:

*git checkout Имя_ветки*

* Создание ветки и переключение на нее:

*git checkout –b Имя_ветки*

* Переименование ветки:

*git branch –m Старое_название_ветки Новое_название_ветки*

* Удаление ветки:

Удалить ветку можно параметром branch с добавлением флага -d и указанием имени ветки. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.

*git branch –d Имя_ветки*

Для принудительного удаления ветки используется флаг -D с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.

*git branch –D Имя_ветки*

 # Алгоритм cлияния веток:

1. Переключиться на ветку, в которой будут приняты изменения:

*git checkout Имя_ветки*

2. Указать ветку, в которой будут приняты изменения:

*git merge ветка_с_нужными_изменениями*

# Конфликты:

Для того, чтобы выяснить, в каких файлах есть конфликты, нужно набрать Git команду: *git status*
Все, что находится в HEAD - это наши изменения, и все, что находится после знаков равно (======)- это внешние изменения.[вот как это выглядит](merge.png)
Вам нужно выбрать, какие изменения оставить.
После того как решите конфликты, нужно использовать Git команду: *git commit*

# Прекращение слияния веток при конфликте

Прервать слияние в случае конфликта можно параметром merge с флагом --abort. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.

* *git merge --abort*

# Откат последнего коммита

Откатить последний коммит можно с помощью параметра revert. Создастся новый коммит, содержащий обратные преобразования относительно предыдущего, и добавится к истории текущей ветки.

*git revert HEAD*

__Разница между revert и reset__

Команда git revert отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда git reset.

У команды revert есть два крупных преимущества по сравнению с reset. Во-первых, она не меняет историю проекта и производит операцию, безопасную для коммитов. Во-вторых, её объектом выступает конкретный коммит, созданный в любой момент истории, а git reset всегда берёт за точку отсчёта текущий коммит. К примеру, если нужно отменить старый коммит с помощью git reset, придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно. Следовательно, команда git revert — гораздо более удобный и безопасный способ отмены изменений.

 # Откат заданного коммита

Откатить проект до заданного коммита можно с помощью параметра revert и идентификатора коммита. Создастся новый коммит — копия коммита с предоставленным идентификатором — и добавится к истории текущей ветки.

*git revert добавляем хэш*
