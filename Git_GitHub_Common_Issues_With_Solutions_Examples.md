
# Давайте рассмотрим коллекцию простых и сложных примеров работы c Git и GitHub:

### Начало работы:

Создание нового репозитория, первый коммит, привязка удалённого репозитория с gthub.com, отправка изменений в удалённый репозиторий.

``` bash
# указана последовательность действий:
# создана директория проекта, мы в ней
git init                      # создаём репозиторий в этой директории
touch readme.md               # создаем файл readme.md
git add readme.md             # добавляем файл в индекс
git commit -m "Старт"         # создаем коммит
git remote add origin https://github.com:yourname/test.git # добавляем предварительно созданный пустой удаленный репозиторий
git push -u origin master     # отправляем данные из локального репозитория в удаленный (в ветку master)
```

### «Внесение изменений» в коммит:

Только если коммит ещё не был отправлен в удалённые репозиторий.

``` bash
# указана последовательность действий:
subl inc/header.html          # редактируем и сохраняем разметку «шапки»
git add inc/header.html       # индексируем измененный файл
git commit -m "Убрал телефон из шапки" # делаем коммит
# ВНИМАНИЕ: коммит пока не был отправлен в удалённый репозиторий
# сознаём, что нужно было еще что-то сделать в этом коммите.
subl inc/header.html          # вносим изменения
git add inc/header.html       # индексируем измененный файл (можно git add .)
git commit --amend -m "«Шапка»: выполнена задача №34" # заново делаем коммит
```
### Работа с ветками:

Есть master (публичная версия сайта), выполняем масштабную задачу (переверстать «шапку»), но по ходу работ возникает необходимость подправить критичный баг (неправильно указан контакт в «подвале»).

``` bash
# указана последовательность действий:
git checkout -b new-page-header # создадим новую ветку для задачи изменения «шапки» и перейдём в неё
subl inc/header.html            # редактируем разметку «шапки»
git commit -a -m "Новая шапка: смена логотипа" # делаем коммит (работа еще не завершена)
# тут выясняется, что есть баг с контактом в «подвале»
git checkout master             # возвращаемся к ветке master
subl inc/footer.html            # устраняем баг и сохраняем разметку «подвала»
git commit -a -m "Исправление контакта в подвале" # делаем коммит
git push                        # отправляем коммит с быстрым критическим изменением в master в удалённом репозитории
git checkout new-page-header    # переключаемся обратно в ветку new-page-header для продолжения работ над «шапкой»
subl inc/header.html            # редактируем и сохраняем разметку «шапки»
git commit -a -m "Новая шапка: смена навигации" # делаем коммит (работа над «шапкой» завершена)
git checkout master             # переключаемся в ветку master
git merge new-page-header       # вливаем в master изменения из ветки new-page-header
git branch -d new-page-header   # удаляем ветку new_page_header
```

### Работа с ветками, слияние и откат к состоянию до слияния:

Была ветка `fix`, в которой исправляли баг. Исправили, влили `fix` в `master`. но тут выяснилось, что это исправление ломает какую-то функциональность, Нужно откатить `master` к состоянию без слияния (наличие бага менее критично, чем порча функциональности).

``` bash
# находимся в ветке fix, баг уже «исправлен»
git checkout master            # переключаемся на master
git merge fix                  # вливаем изменения из fix в master
# видим проблему: часть функциональности сломалась
git checkout fix               # переключаемся на fix (пока мы в master, git не даст ее двигать)
git branch -f master ORIG_HEAD # передвигаем ветку master на коммит, указанный в ORIG_HEAD (тот, на который указывала master до вливания fix)
```

### Откат указанного файла к состоянию на момент определённого коммита:
 
``` bash
Также можно использовать git checkout для восстановления изменений конкретного файла:
git checkout хеш yourfile.html  --> восстановить в рабочей директории указанный файл на момент указанного коммита и добавить это изменение в индекс (git reset yourfile.html для удаления из индекса, но сохранения изменений в файле)
```
### Перенос ветки "вручную" и откат изменений на главной ветке:

Механизм создания новых веток не так прост, как может показаться некоторым на  первый взгляд. Так данный функционал можно использовать для отката ветки к предыдущему состоянию с сохранением данных --> Например: мы реализовали механизм проверки пароля для личного кабинета в нашем проекте и сделали коммит в основной ветке где как правило хранится окончательный код, но после ряда обсуждений пришли к выводу что надо добавить капчу при проверке пароля.
Как нам откатить нашу ветку main __or__ master и при этом вернуться к требуемому коду чтобы его доработать?
Всё просто: мы находимся на гланой ветке и наш HEAD указывает на эту ветку, которая  в свою очередь указывает на текущий коммит - пусть это будет коммит с хешем 4594. Давайте создадим новую ветку git branch fix. Мы всё еще на гланой ветке и обе ветки master & fix указывают на один и тот же коммит 4594. Переходим на ветку fix --> *git checkout fix*. А теперь давайте [передвинем главную ветку](Project_Images/FiXBranch.png) к состоянию предыдущего коммита когда механизм реализации пароля еще не был добавлен в репозиторий. Воспользуемся командой которую мы уже знаем: *git branch -f master 54a4* где хеш 54a4 указывает на интересующий нас коммит а ключ -f (force) использован чтобы заставить Git создать новую ветку master, хотя такая ветка уже существует. Теперь мы можем вести разработку в новой ветке fix, а основная ветка вернулась к прердыдущему состоянию благодаря нашему переносу веток "вручную"
[Вот так это выглядит](Project_Images/FixBranchWorked.png)
Если  допустим мы передумали - можем вернуть master обратно к состоянию ветки fix ссылающейся на коммит с хешем 4594 --> *git branch -f master fix* [И вот что получится --> тык](Project_Images/FixBranchAndMasterOnTheSameCommit.png). В Git ветка не может указывать на другую ветку - только на коммит. Поэтому fix в комманде выше это идентификатор коммита с хешем 4594. Для перемещения главной ветки также можно было использовать команду: *git checkout -B master 54a4*. 
[По сути это тоже самое что](Project_Images\FixBranchCheckout.png) --> *git checkout fix* + *git branch -f master 54a4*.
### Отмена или сохранение всех незакоммиченных изменений в проекте:

Допустим мы осуществили какие-то изменения в нашем проекте, но пока что они сырые и мы их не можем зафиксировать. Вдруг нам нужно срочно переключить ветку - скажем на main... Мы используем *git checkout main* , но Git отказывается переходить и бьёт тревогу потому что данные для которых мы не сделали коммит могут безвозвратно кануть в бездну небытия:). Это работает следующим образом: если просто переключить ветки посреди работы, то все изменённые файлы перенесутся в новую ветку, а если изменнения конфликтуют, то и не переключится ничего. Какие варианты у нас тогда есть? Допустим мы подумали и решили что не нужны нам все эти данные, но ветку мы всё-таки хотим поменять - тогда просто добавим флаг -f который обозначает force.
Вводим комманду *git checkout -f main* и переходим на главную ветку.
Используя этот принцип можно всегда откатить все изменения которые мы проделали в проекте, но не закоммтили -  "git checkout -f" по умолчанию ссылается на HEAD (текущую ветку). Находясь в HEAD вводим эту комманду *git checkout -f* но смены ветки как таковой фактически не происходит ведь мы остаёмся там же, однако Git перезаписывает все файлы заменяя их версиями из репозитория на момент HEAD.
Теперь давайте расссмотрим вариант когда данные нам всё-таки нужны, но коммит еще совершать нецелесообразно: для этого есть комманда *git stash* Этак команда собирает все изменнения без коммитов, удаляет их из файлов и архивирует в специальном виде в Git.(a stash c английского - заначка, тайник) Чтобы вернуть изменения из нашего тайника надо вернуться на соотвествующую ветку и использовать *git stash pop*  При желании и необходимости можно вызвать эту комманду на другой ветке и перенести все наши изменнения туда, однако стоит быть очень аккуратным чтобы не создать конфликты при таком переносе поэтому чаще всего возвращаются на исходную ветку.

### Работа с ветками, конфликт слияния:

Есть ветка `master` (публичная версия сайта), в двух параллельных ветках (`branch-1` и `branch-2`) было отредактировано одно и то же место одного и того же файла, первую ветку (`branch-1`) влили в master, попытка влить вторую вызывает конфликт.

``` bash
# указана последовательность действий:
git checkout master           # переключаемся на ветку master
git checkout -b branch-1      # создаём ветку branch-1, основанную на ветке master
subl .                        # редактируем и сохраняем файлы
git commit -a -m "Правка 1"   # коммитим
git checkout master           # возвращаемся к ветке master
git checkout -b branch-2      # создаём ветку branch-2, основанную на ветке master
subl .                        # редактируем и сохраняем файлы
git commit -a -m "Правка 2"   # коммитим
git checkout master           # возвращаемся к ветке master
git merge branch-1            # вливаем изменения из ветки branch-1 в текущую ветку (master), удача (автослияние)
git merge branch-2            # вливаем изменения из ветки branch-2 в текущую ветку (master), КОНФЛИКТ автослияния
# Automatic merge failed; fix conflicts and then commit the result.
subl .                        # выбираем в конфликтных файлах те участки, которые нужно оставить, сохраняем
git commit -a -m "Устранение конфликта" # коммитим результат устранения конфликта
```

### Синхронизация репозитория-форка с мастер-репозиторием:

Есть некий репозиторий на github.com, он него нами был сделан форк, добавлены какие-то изменения. Оригинальный (мастер-)репозиторий был как-то обновлён. Задача: стянуть с мастер-репозитория изменения (которые там внесены уже после того, как мы его форкнули).

``` bash
# указана последовательность действий:
git remote add upstream https://github.com:address.git # добавляем удаленный репозиторий: сокр. имя — upstream, URL мастер-репозитория
git fetch upstream            # стягиваем все ветки мастер-репозитория, но пока не сливаем со своими
git checkout master           # переключаемся на ветку master своего репозитория
git merge upstream/master     # вливаем стянутую ветку master удалённого репозитория upstream в свою ветку master
```

### Ошибка в работе: закоммитили в мастер, но поняли, что нужно было коммитить в новую ветку:

**ВАЖНО: это сработает только если коммит еще не отправлен в удалённый репозиторий.**

``` bash
# указана последовательность действий:
# сделали изменения, проиндексировали их, закоммитили в master, но ЕЩЁ НЕ ОТПРАВИЛИ (не делали git push)
git checkout -b new-branch    # создаём новую ветку из master
git checkout master           # переключаемся на master
git reset HEAD~ --hard        # сдвигаем указатель (ветку) master на 1 коммит назад
git checkout new-branch       # переключаемся обратно на новую ветку для продолжения работы
```

### Нужно вернуть содержимое файла к состоянию, бывшему в каком-либо коммите (известен хеш коммита):

``` bash
# указана последовательность действий:
git checkout f26ed88 -- index.html # восстановить в рабочей директории состояние указанного файла на момент указанного коммита, добавить это изменение в индекс
git commit -am "Navigation fixs"   # сделать коммит
```

### При любом действии с github (или другим удалённым сервисом) запрашивается логин и пароль:

Речь именно о запросе пары логин + пароль, а не ключевой фразы. Происходит это потому, что git по умолчанию не сохранит пароль для доступа к репозиторию по HTTPS.

Простое решение: [указать git кешировать ваш пароль](https://help.github.com/articles/caching-your-github-password-in-git/).

## `.gitattributes`
Некоторые из настроек могут быть применены к каталогу, поэтому Git применяет их только к подкаталогам или набору файлов. Настройки, зависящие от пути, называются атрибутами и могут быть установлены либо в файле .gitattributes в любом из каталогов проекта (обычно, в корневом каталоге), либо в файле .git/info/attributes, если вы не хотите хранить их в репозитории вместе с вашим проектом.
Используя атрибуты, вы можете настраивать различные стратегии слияния для отдельных файлов или каталогов вашего проекта, указать Git как сравнивать бинарные файлы, настраивать фильтры добавления или извлечения данных из репозитория.

```
* text=auto

*.html diff=html
*.css  diff=css
*.scss diff=css
```