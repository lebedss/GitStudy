# Удалённые репозитории --> GitHub

Чтобы воспользоваться сервисом, нужно зайти на сайт GitHub (https://github.com/) и зарегистрировать нового пользователя. Придумайте имя и пароль, а также введите e-mail, к которому у вас есть доступ:

[Это выглядит как-то так](Project_Images/CreateAccountOnGitHub.png)

Не забудьте верифицировать аккаунт: откройте первое письмо на почте от GitHub и пройдите по ссылке. Иначе вы не сможете создавать репозитории.

Теперь, когда у вас есть свой аккаунт, нужно залогиниться в самой консоли (привет, любимый терминал!), чтобы связать их. Для этого понадобится выполнить команды в консоли, которые зададут имя пользователя и почтовый ящик.

*git config --global user.name "user-name"*

*git config --global user.email "email@example.com"*

Вместо user-name подставьте логин, который указывали при регистрации. В случае на скриншоте это test-github-04, а вместо email@example.com — адрес вашей электронной почты. В данном примере — testgithub@gmail.com.

[Вот что у нас должно получиться](Project_Images/adjusting_github_account_details_via_git.png)

Если вы всё сделали по инструкции, то при выполнении команды *git config --list* отобразится [ваше имя пользователя и e-mail](Project_Images/AdjustingGitHubAccountDetailsViaGit2.png)

**Если на момент регистрации акаунта на GitHub вы уже настроили и установили сам Git и при этом Вы уже внесли какие-то данные - не переживайте, просто воспользуйтесь выше указанными командами и обновите имя пользователя и e-mail используя новые данные которые вы вносили при регистрации на GitHub**

# Как опубликовать первый проект на GitHub:
Зайдите в ваш профиль: для этого кликните по иконке в правом верхнем углу и нажмите 
[Your Profile](Project_Images/HowToStartNewProjectOnGitHub.png)

Теперь создайте репозиторий: перейдите во вкладку Repositories и кликните по кнопке 
[New](Project_Images/NewRepositoriyCreation.png)

Задайте имя репозитория. На скриншоте название проекта test-github и он сделан публичным, чтобы его могли просматривать все пользователи. Далее нажмите кнопку:
[Create repository](Project_Images/Create_a_new_repository.png)

Пока проект пустой, но мы можем поместить в него наши файлы с нашего компьютера.

Есть два распространённых способа привязать удалённый репозиторий к локальному: по HTTPS и по SSH. Если SSH у вас не настроен (или вы не знаете что это), привязывайте удалённый репозиторий по HTTPS (адрес привязываемого репозитория должен начинаться с https://).
Чаще всего используют протокол HTTPS — с ним проще работать с Git, чем с SSH.

Подробнее про различия протоколов можно прочитать в приложенной к данному проекту документации: 
[см. стр.109](Project_Documentation/progit.pdf)

Github предлагает [несколько вариантов действий при создании проекта:](Project_Images/OptionsForRepositoriesCreation.png)

0. Клонировать папку нашего проекта согласно выбранному протоколу HTTPS либо SSH 
1. Создать абсолютно новый проект с нуля 
2. Опубликовать на GitHub уже созданный "локальный" проект размещенный на компьютере.
3. Скопировать и импортировать на GitHub чей-то проект из другого репозитория

*Давайте разбираться что все это собственно значит :-)*

# __Что же такое клонирование?__

Это копирование удаленного репозитория на локальную машину. Обычно это первое действие при работе с проектом. При клонировании на нашу машину копируются файлы и папки проекта и вся его история. То есть мы получаем доступ к истории не с момента начала нашей работы над проектом, а с самого начала проекта.

__Как клонировать готовый проект?__

В первую очередь, нужно получить ссылку на проект. Мы можем найти ее сами или получим готовую, например, на новой работе. Возьмем для примера мой репозиторий lebedss - https://github.com/lebedss/GitStudy.git

Наберем в командной строке  терминала в  нашей среде разработки (в данном случае VS CODE):

*git clone https://github.com/lebedss/GitStudy.git*

При этом в текущем каталоге создастся папка GitStudy, в ней окажутся все файлы проекта GitStudy и специальная скрытая папка .git, то есть сам репозиторий, или информация о нем. При использовании команды *git clone <url репозитория>* мы не только загружаем себе копию репозитория, но и неявно отслеживаем удалённый сервер, который находится по указанному адресу и которому присваивается имя origin.

__Как клонировать проект в другую папку?__
При клонировании по умолчанию создается папка с таким же названием, как и у репозитория. Но можно склонировать репозиторий и в другую папку вот так

*git clone https://github.com/lebedss/GitStudy.git new_specific_folder*

Где new_specific_folder - нужное название папки.

    Важно понимать что что при клонировании репозитория на наш компьютер клонируются все ветки этого удалённого репозитория. Но есть важный момент: они имеют префикс origin/имя удалённой ветки, а вот отслеживаемой становится только ветка master -> origin/master ну или же main -> origin/main (в зависимости от использованного имени для главной ветки)
    Для того, чтобы сделать ещё одну отслеживаемую ветку - переключитесь на удалённую ветку которую хотите добавить в отслеживаемые.

**Что же всё это значит? Элементарно, Ватсон! - смотри сюда:**

* У нас есть удалённый репозиторий : https://github.com/febblin/GitHubTest.git

* В этом проекте есть 2 ветки : [main и newBranch](Project_Images/BranchesMainAndNewBranch.png)
Мы решили склонировать данный репозиторий к себе на компьютер:

* добавили ответвление проекта в свой акаунт GitHub. В правом верхнем углу тыкнули кнопку форк у проекта который мы хотим к себе скопировать (см выше о чём речь), затем нажали [create fork](Project_Images/CreateNewFork.png)

* [Скопировали ссылку на ответвление проекта расположенное на нашем акаунте GitHub](Project_Images/ReferencToProjectAfterFork.png)

* Воспользовались командой с терминала в VS CODE: *git clone https://github.com/lebedss/GitHubTest.git*

* Запустили систему контроля версий GIT --> команда: *git init*

* Перешли в папку где находится наш проект --> *cd /GitHubTest*.

* Что за зверь такой - команда:*cd* ? --> [тык сюда](GitNavigationUsingTerminal.md)

* Решили проверить какие же ветки есть в склонированном проекте с помощью команды [*git branch*](Project_Images/OnlyMainBranchAfterCloning.png) и ужаснулись потому что у нас только одна ветка main и кто-то украл newBranch.

* Рано бить тревогу, просто Git временно бросил newBranch на произвол судьбы и не присматривает за ним в данный момент, но это ведь не значит что эта ветка не существует...Чтобы убедиться что ветку не потеряли и не украли давайте обратимся к команде: *git branch -a* (посмотреть **полный** список локальных и удаленных веток.) [Вот newBranch и нашлась](Project_Images/GitBranchAll.png)

* Всё что нам теперь нужно попросить Git "пойти и проведать" newBranch  с помощью команды перехода на другую
ветку *git checkout newBranch*. [Теперь когда мы тыкнули пальцем старый и слепой Git нашёл ёё](Project_Images/AddBranchIntoIndexAfterClone1.jpg). Это также значит что Git воспринимает теперь newBranch не как удалённую ветку (remotes/origin/newBranch) , а как локальную ветку (origin/newBranch).

* Теперь давайте убедимся что репозиторий полностью склонирован и все ветки в наличии. 
Воспользуемся коммандой:[*git branch*](Project_Images/NewBranchFoundAfterCloning.png). 
Всё ok - в нашем склонированом проекте есть 2 ветки main и newBranch, что соответсвует изначальному репозиторию.

# Создание проекта на GitHub с нуля:

[При помощи команды cd нужно найти нужную папку](Project_Images/HowToFindCorrectDirectoryForNewProject.png)

Поэтапно следуем командам которые предлагает нам GitHub:

1. echo "# YourRepositoryName" >> README.md
2. git init
3. git add README.md
4. git commit -m "first commit"
5. git branch -M main
6. git remote add origin https://github.com/YourGitHubName/YourRepositoryName.git
7. git push -u origin main

**1-ая команда:**

echo "# YourRepositoryName" >> README.md добавляет новый файл в проект. 

[Его также можно создать вручную в папке](Project_Images/EchoReadmeMD.png)

**2-ая команда:**

[git init — инициализирует проект.](Project_Images/GitInit.png)

После инициализации создаётся специальная скрытая папка для Git:

__Тут необходимо заглянуть [сюда](Bash_Commands/Bash_Guide_For_Windows.md) для пояснения ряда команд на скриншотах.__

**3-ая команда:**
[git add README.md — добавляет изменённые файлы к коммиту](Project_Images/git_add_READMEmd.png)
Также это можно сделать при помощи команды git add . — в таком случае вы добавите не конкретные файлы, а все изменённые, если их много.
[git status поможет проверить, что происходит с изменёнными файлами.](Project_Images/git_status.png)
В нашем случае, например, файлы не прикреплены к коммиту

**4-ая команда:**

[git commit -m "first commit" добавляет сообщение к коммиту — то, что будет отображаться в истории](Project_Images/git_commit_m_first_commit.png)
Теперь снова посмотрим, что скажет git status. Сейчас он пустой, так как все изменённые файлы мы прикрепили к только что созданному коммиту

**5-ая команда:**

[git branch -M main переименовывает ветку в main](Project_Images/git_branch_M_main.png)
В нашем примере текущая ветка называется master. Но с 2020 года GitHub выступает за то, чтобы главная ветка называлась main (по политическим причинам) и рекомендует переименовать ветку с помощью команды git branch -M main.

В скобках можно указать любой текст. Как правило, в нём кратко описывают, что делали в коммите.
Теперь снова посмотрим, что скажет git status. Сейчас он пустой, так как все изменённые файлы мы прикрепили к только что созданному коммиту

**6-ая команда:**

[Получаем такой результат](Project_Images/git_remote_add_origin.png)

Команда git remote add origin https://github.com/YourGitHubName/YourRepositoriyName.git добавляет сервер, где origin — это имя сервера, а url — это адрес.
У вас может быть несколько удалённых серверов, с которыми работает проект. 
Проверить добавленные сервера можно командой *git remote -v* (fetch — откуда забирать, push — куда отправлять изменения).

**7-ая команда:**

[git push -u origin main позволяет запушить (отправить) ветку main на сервер origin](Project_Images/git_push_u_origin_main.png)

__Тут вам, скорее всего, потребуется связать приложение и GitHub, повторно залогинившись через браузер.__

# Опубликовать на GitHub уже существующий "локальный" проект (размещенный на компьютере) с помощью терминала:

"push an existing repository from the command line"

Предполагается, что вы создали свой репозиторий на GitHub, и в настоящее время он пуст.
Наш локальный проект на компьютере  может размещается в любом каталоге. Для него нужно инициализировать git. 
Это стандартная процедура: *git init* + *git add .* + *git commit -m "Initinal commit"*

Поэтапно следуем командам которые предлагает нам GitHub:

**1-ая команда:**

*git remote add origin https://github.com/YourGitHubName/YourRepositoriyName.git*

Для связи с GitHub указали удаленный репозиторий. 

[Адрес на сайте Github](Project_Images/RepositoriyAdress.png)

**2-ая команда:**

*git branch -M main*

Переименовываем главную ветку в main 

**3-ая команда:**

*git push -u origin main*

Отправляем все изменения на сервер GitHub. Если мы теперь зайдем на страницу репозитория на GitHub, то увидим свой проект.

# Импортировать код из какого-то другого репозитория в свой:

1. [Жмём кнопку Import Code](Project_Images/import_code_from_another_repository1.png)

2. [Вставляем ссылку на репозиторий который хотим импортировать](Project_Images/import_code_from_another_repository2.png) и нажимаем Begin import

3. [Ждём когда процесс импорта закончится](Project_Images/import_code_from_another_repository3.png)


### Наиболее употребляемые команды для работы с удалёнными репозиториями:

``` bash
git remote -v              # выводит список удалённых репозиториев,связанных с локальным которые мы отслеживаем, и имена, которые мы им присвоили.
git branch -r              # показать удаленные ветки
git branch -a              # показать все ветки(локальные и удаленные)       
git remote remove origin   # убрать привязку удалённого репозитория с сокр. именем origin
git remote add origin https://github.com:yourname/test.git # добавить удалённый репозиторий (с сокр. именем origin) с указанным URL
git remote rm origin       # удалить привязку удалённого репозитория
git remote show origin     # получить данные об удалённом репозитории с сокращенным именем origin
git remote rename <старое имя> <новое имя> # переименовывает удалённый репозиторий;
git remote set-url <имя> <url> # присваивает репозиторию с именем новый адрес;
git fetch origin           # скачать все ветки с удаленного репозитория (с сокр. именем origin), но не сливать со своими ветками
git fetch origin master    # то же, но скачивается только указанная ветка
git checkout --track origin/github_branch # создать локальную ветку github_branch (данные взять из удалённого репозитория с сокр. именем origin, ветка github_branch) и переключиться на неё
git push origin master     # отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master
git pull origin            # влить изменения с удалённого репозитория (все ветки)
git pull origin master     # влить изменения с удалённого репозитория (только указанная ветка)
```
Если локальная ветка уже отслеживает удалённую, то можно использовать просто *git push* или *git pull.*

Команда git pull отвечает за скачивание данных с сервера. Процесс очень похож на клонирование репозитория, но здесь скачиваются не все коммиты, а только новые. 

По сути, git pull — это сочетание команд git fetch (загружает коммиты, ссылки, файлы из удаленного репозитория в локальный) и git merge (объединяет несколько коммитов в один общий).
Команда git merge связывает ряд коммитов в одно целое. В свою очередь git создает коммит слияния, где и объединяются изменения обеих последовательностей.

На первой стадии git pull выполняется команда fetch, ограниченная локальной веткой. Затем команда git pull выполняет слияние и формируется новый коммит.

# Совет : Применяйте pull только как fast-forward

На всякий случай, напоминаю, что pull по умолчанию делает fetch (выкачивание ветки с удалённого репозитория) и merge (слияние локальной и удалённой веток), а fast-forward — это режим слияния, когда нет никаких изменений в локальной ветке и происходит "перемотка" её на последний коммит из удалённой. Если изменения есть, то происходит классический мерж с ручным разрешением конфликтов и merge-commit.

Некоторые предпочитают использовать git pull --rebase, но не всегда это возможно, например, когда вы локально смержили другую ветку из origin в master и перед пушем делаете pull (надеюсь, не надо напоминать, чем в данном случае может грозить rebase).

Соответственно, чтобы не попасть случайно в ситуацию, когда Вы неудачным pull-ом смержили не то и не туда, можно использовать параметр --ff-only или вписать соответствую опцию в конфиг: *git config --global pull.ff only*

Что мы получаем?

* Автоматический фейл, если в локальной ветке есть новые незапушенные коммиты.
* Автоматический фейл, если во входящей ветке есть изменения в тех же файлах, в которых у Вас есть локальные незакоммиченные изменения (а это с большой вероятностью может вылиться потом в конфликт мержа).
* Автоматический фейл, если Вы случайно делаете pull не в ту ветку — например, на автомате вписали git pull origin master upstream вместо my_feature.
* Успех, когда всё прекрасно.


# GitHub - Внесение собственного вклада в другие проекты *Создание ответвлений (fork)*

Если вы хотите вносить свой вклад в уже существующие проекты, в которых у нас нет прав на внесения изменений путём отправки (push) изменений, вы можете создать своё собственное ответвление (fork) проекта. Это означает, что GitHub создаст вашу собственную копию проекта, данная копия будет находиться в вашем ведении и вы сможете легко делать изменения путём отправки (push) изменений.

* Шаг 1-ый: для того, чтобы создать ответвление проекта, зайдите на страницу проекта на GitHub и нажмите кнопку «Создать ответвление» («Fork»),[нажимаем кнопку](Project_Images/forkbutton.png) которая расположена в правом верхнем углу. [Просто тыкни](Project_Images/Fork.png))

* Шаг 2-ой: [клонируйте проект на свою машину](Project_Images/CloneYourProjectToPC.png)
Перейдите в свой "форк" репозитория (который теперь находится в ваших репозиториях GitHub).Затем клонируйте проект на свой компьютер, введя в окне вашего терминала:*git clone <скопированный-адрес>*
Переходим в клонированную директорию:*cd [имя репозитория]*
Для того, чтобы работать внутри созданного каталога, в него требуется перейти командой cd name. Это справедливо и при клонировании удалённого репозитория с помощью команды *git clone <скопированный-адрес>.* Полностью склонированный репозиторий создаст каталог в текущей директории с именем проекта, в который нужно перейти командой *cd <имя репозитория>*
Например: https://github.com//ShafigullinIK/group_903.git - наш проект от которого мы взяли fork. После клонирования и применения git init мы [видим папку:](Project_Images/TestFolder.png) group_903 в нашей папке Test которую мы предварительно создали, однако терминал нам говорит когда мы спрашиваем где мы собственно сейчас ([команда pwd](Project_Images/pwd.png)), что мы в папке TEST, но не group_903 где находится наш репозиторий и куда нам нужно поэтому используем команду [cd group_903/](Project_Images/cd_repository_name.png) Для более детального ознакомления с командами Git по работе с дерикториями через терминал
[тык сюда](Bash_Commands\Bash_Guide_For_Windows.md)

* Шаг 3-ий: [создание upstream](Project_Images/UpstreamCreation.png)
Вам нужно отслеживать разницу между вашим "форком" репозитория в вашем аккаунте на GitHub и оригинальным репозиторием. Это особенно полезно, если вы хотите принять участие в работе над каким-то популярным репозиторием. Некоторые репозитории делают слияние "пул-реквестов" каждый час или даже чаще, так что вам нужно следить за тем, чтобы ваш форк не отставал от оригинального репозитория. В этом вам поможет upstream - "верхнее течение" c английского языка.
Для создания ссылки на оригинальный репозиторий введите в терминале следующую команду:
*git remote add upstream <скопированный-адрес-upstream>* (скопированный-адрес-upstream это адрес оригинального репозитория от которого мы делали ответвление, а не сам форк) 
[Визуально это выглядит вот так](Project_Images/Fork-Repository.png)

Далее можно выполнить команду *git pull upstream master* чтобы убедиться, не произошло ли каких-то изменений (с того момента как вы сделали форк и до настоящей минуты).

* Шаг 4-ый: создание отдельной новой ветки (branch), над которой вы будите работать.
Когда вы хотите что-либо изменить в проекте, будет хорошей идеей создать для этих изменений отдельную ветку. Это будет демонстрировать, что ветка предназначена только для той работы, которую вы хотите сделать. Такой работой может быть и исправление опечатки, и реализация новой фичи. В любом случае, будет хорошим тоном создать новую ветку.
Также имеет значение присвоение имён. Будет любезно с вашей стороны использовать имя, которое легко сможет понять человек, ничего не знающий об этом репозитории. Например, если вы хотите добавить возможность логиниться в приложении, можно создать ветку под названием new_branch_for_login_feature
Для создания ветки введите в терминале следующую команду:*git checkout -b new_branch* 
Будет создана ветка и сразу осуществлен переход в нее.
После этого можно начинать вносить свои изменения в ветку (исправлять опечатку, писать код фичи и т. д.).

* Шаг 5: Git add и commit изменений
Это тоже достаточно просто. Вам нужно подготовить ваши изменения и сделать коммит (запись изменений), введя следующие команды в терминале: *git add .* +  *git commit -m 'Сообщение коммита'* Теперь ваши изменения подготовлены и записаны в ваш репозиторий.

* Шаг 6: pull (получение данных) из upstream в вашу ветку
Этот шаг сольет (merge) любые изменения, произошедшие в upstream (оригинальном репозитории), с вашей веткой, чтобы избежать конфликтов.
*git pull upstream <имя-ветки над которой вы работаете>*

* Шаг 7: push (помещение данных) в ветку, в которой вы работаете
Все почти готово. «Пушим» изменения в свою рабочую ветку:*git push origin <имя-ветки над которой вы работаете>*

Шаг 8: [нажимаем contribute -> open pull request](Project_Images/ContributeButton.png) на GitHub

Это финальный шаг, который делает контрибутор open source проекта. На этом этапе вы будто говорите: «Я внес некоторые изменения, не будете ли вы так любезны добавить их в проект?»
Вы открываете pull request, и если собственнику репозитория или людям, занимающимся его поддержкой, ваши изменения понравятся, они сольют их со своим проектом (merge). Также они могут внести какие-то изменения, а уж затем выполнить слияние, или запросить эти изменения. Для открытия pull request перейдите в ваш fork репозитория, как показано ниже. Вы увидите последнюю ветку, в которую вы делали push. Кликните на «compare and pull request». [Четко поясните, что именно вы изменили, и создайте pull request](Project_Images/CreatePullRequest.png)

**Комментарии очень важны: присвойте имя и сделайте описание максимально чётким но при этом лаконичным и ёмким!**

[Создание комментариев для pull request](Project_Images/CommentsForPullRequest.png)

[Полученный комментарий через pull request](Project_Images/CommentsForPullRequestsWereSent.png)

В конечном счёте владелец проекта которому прислали pull request может либо принять предлагаемые изменения - кнопка: confirm merge либо же отклонить - кнопка: close pull request. 

Именно благодаря наличию системы комментариев отсеивается огромное количество конфликтов и багов...
[Выглядит это так](Project_Images/MergePullRequest.png)

**Заключение о создании ответвлений (fork):** 

Данная схема работы над проектами очень удобна  - главное осознать и  запомнить 

[алгоритм создания и работы с fork](Project_Images/1_Pull-Request.png)

# Alias для создания удаленного репозитория GitHub в Git Bash:

Если вы используете в качестве удаленного репозитория GitHub, то наверняка сталкивались с такой проблемой – как создать новый репозиторий из консоли. Например: вы создали новый репозиторий на локальной машине, делали в нем изменения файлов. И вот когда закончили и решили запушить это на GitHub, то вам выдается ошибка, что на BB репозитория нет и его надо сначала создать. Вы идете на сайт GitHub-а, создаете там пустой репозиторий, потом из консоли Git Bash делаете связку с удаленным репозиторием. Не слишком изящно, да? Если у вас нет возможности установить дополнительные инструменты, то тут как раз подойдет создание новой команды. На площадке GitHub есть API, который позволяет исполнять команды для различных действий.
Вы можете создать репозиторий GitHub через командную строку с помощью API GitHub. Проверьте API репозитория. Если вы прокрутите вниз около трети пути, вы увидите раздел под названием ["создать"](https://docs.github.com/en/rest/repos#create) это объясняет, как создать РЕПО через API (прямо над этим раздел, в котором объясняется, как развить РЕПО с API, тоже). Очевидно, вы не можете использовать git для этого, но вы можете сделать это через командную строку с такой инструмент, как curl.За пределами API, нет никакого способа создать РЕПО на GitHub через командную строку.GitHub не разрешает доступ к оболочке и т. д., поэтому, помимо API GitHub, единственный способ создать РЕПО-через веб-интерфейс GitHub.

Это можно сделать с помощью трех команд (обновлено для V3 GitHub API):

``` bash
curl -u 'nyeates' https://api.github.com/user/repos -d '{"name":"projectname","description":"This project is a test"}'
git remote add origin git@github.com:nyeates/projectname.git
git push origin master
```
### Пояснения:

1. Cоздать GitHub репозиторий

```bash
curl -u 'nyeates' https://api.github.com/user/repos -d '{"name":"projectname","description":"This   project is a test"}'
```
* curl-это команда unix (она также работает на mac), которая извлекает и взаимодействует с URL-адресами. Обычно он уже установлен.
* " - u " - это параметр curl, который задает имя пользователя и пароль для проверки подлинности сервера.
если вы просто дадите имя пользователя (как показано в примере выше), curl запросит пароль.
если вы не хотите вводить пароль, см. документацию по api GitHub по [проверке подлинности.](https://docs.github.com/en/rest#authentication)
* " - d " - это параметр curl, который позволяет отправлять почтовые данные с запросом
вы отправляете почтовые данные в GitHub - [определенный API формат](https://docs.github.com/en/rest/repos#create)
* " имя "- это единственные необходимые данные POST; мне нравится также включать "описание"

2. Добавить адрес подключенного (удаленного) репозитория на GitHub:

```bash
git remote add origin git@github.com:nyeates/projectname.git
```
* "origin" - это имя по умолчанию, используемое git для источника он
технически не пришел из GitHub, но теперь репозиторий GitHub будет источником записи
* "git@github.com:nyeates" это ssh-соединение, которое предполагает, что вы уже настроили доверенную пару ключей ssh с github.

3. Делаем push в репозиторий на GitHub из главной локальной ветви:

``` bash
git push origin master
```
## Дополнительно:

*Бесплатный курс по GIT и Github из 6 уроков c развернытыми статьями и практическими заданиями*

https://smartiqa.ru/courses/git